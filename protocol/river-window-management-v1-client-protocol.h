/* Generated by wayland-scanner 1.24.0 */

#ifndef RIVER_WINDOW_MANAGEMENT_V1_CLIENT_PROTOCOL_H
#define RIVER_WINDOW_MANAGEMENT_V1_CLIENT_PROTOCOL_H

#include <stdint.h>
#include <stddef.h>
#include "wayland-client.h"

#ifdef  __cplusplus
extern "C" {
#endif

/**
 * @page page_river_window_management_v1 The river_window_management_v1 protocol
 * frame-perfect window management
 *
 * @section page_desc_river_window_management_v1 Description
 *
 * This protocol allows a single "window manager" client to determine the
 * window management policy of the compositor. State is globally
 * double-buffered allowing for frame perfect state changes involving multiple
 * windows.
 *
 * The key words "must", "must not", "required", "shall", "shall not",
 * "should", "should not", "recommended", "may", and "optional" in this
 * document are to be interpreted as described in IETF RFC 2119.
 *
 * @section page_ifaces_river_window_management_v1 Interfaces
 * - @subpage page_iface_river_window_manager_v1 - window manager global interface
 * - @subpage page_iface_river_window_v1 - a logical window
 * - @subpage page_iface_river_decoration_v1 - a window decoration
 * - @subpage page_iface_river_shell_surface_v1 - a surface for window manager UI
 * - @subpage page_iface_river_node_v1 - a node in the render list
 * - @subpage page_iface_river_output_v1 - a logical output
 * - @subpage page_iface_river_seat_v1 - a window management seat
 * - @subpage page_iface_river_pointer_binding_v1 - configure a pointer binding, receive trigger events
 * @section page_copyright_river_window_management_v1 Copyright
 * <pre>
 *
 * SPDX-FileCopyrightText: Â© 2024 Isaac Freund
 * SPDX-License-Identifier: MIT
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to
 * deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
 * sell copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 * </pre>
 */
struct river_decoration_v1;
struct river_node_v1;
struct river_output_v1;
struct river_pointer_binding_v1;
struct river_seat_v1;
struct river_shell_surface_v1;
struct river_window_manager_v1;
struct river_window_v1;
struct wl_surface;

#ifndef RIVER_WINDOW_MANAGER_V1_INTERFACE
#define RIVER_WINDOW_MANAGER_V1_INTERFACE
/**
 * @page page_iface_river_window_manager_v1 river_window_manager_v1
 * @section page_iface_river_window_manager_v1_desc Description
 *
 * This global interface should only be advertised to the window manager
 * process. Only one window management client may be active at a time. The
 * compositor should use the unavailable event if necessary to enforce this.
 *
 * There are two disjoint categories of state managed by this protocol:
 *
 * Window management state influences the communication between the server
 * and individual window clients (e.g. xdg_toplevels). Window management
 * state includes window dimensions, fullscreen state, keyboard focus,
 * keyboard bindings, and more.
 *
 * Rendering state only affects the rendered output of the compositor and
 * does not influence communication between the server and individual window
 * clients. Rendering state includes the position and rendering order of
 * windows, shell surfaces, decoration surfaces, borders, and more.
 *
 * Window management state may only be modified by the window manager as part
 * of a manage sequence. A manage sequence is started with the manage_start
 * event and ended with the manage_finish request. It is a protocol error to
 * modify window management state outside of a manage sequence.
 *
 * A manage sequence is always followed by at least one render sequence. A
 * render sequence is started with the render_start event and ended with the
 * render_finish request.
 *
 * Rendering state may be modified by the window manager during a manage
 * sequence or a render sequence. Regardless of when the rendering state is
 * modified, it is applied with the next render_finish request. It is a
 * protocol error to modify rendering state outside of a manage or render
 * sequence.
 *
 * The server will start a manage sequence by sending new state and the
 * manage_start event as soon as possible whenever there is a change in state
 * that must be communicated with the window manager.
 *
 * If the window manager client needs to ensure a manage sequence is started
 * due to a state change the compositor is not aware of, it may send the
 * manage_dirty request.
 *
 * The server will start a render sequence by sending new state and the
 * render_start event as soon as possible whenever there is a change in
 * window dimensions that must be communicated with the window manager.
 * Multiple render sequences may be made consecutively without a manage
 * sequence in between, for example if a window independently changes its own
 * dimensions.
 *
 * To summarize, the main loop of this protocol is as follows:
 *
 * 1. The server sends events indicating all changes since the last
 * manage sequence followed by the manage_start event.
 *
 * 2. The client sends requests modifying window management state or
 * rendering state (as defined above) followed by the manage_finish
 * request.
 *
 * 3. The server sends new state to windows and waits for responses.
 *
 * 4. The server sends new window dimensions to the client followed by the
 * render_start event.
 *
 * 5. The client sends requests modifying rendering state (as defined above)
 * followed by the render_finish request.
 *
 * 6. If window dimensions change, loop back to step 4.
 * If state that requires a manage sequence changes or if the client makes
 * a manage_dirty request, loop back to step 1.
 *
 * For the purposes of frame perfection, the server may delay rendering new
 * state committed by the windows in step 3 until after step 5 is finished.
 *
 * It is a protocol error for the client to make a manage_finish or
 * render_finish request that violates this ordering.
 * @section page_iface_river_window_manager_v1_api API
 * See @ref iface_river_window_manager_v1.
 */
/**
 * @defgroup iface_river_window_manager_v1 The river_window_manager_v1 interface
 *
 * This global interface should only be advertised to the window manager
 * process. Only one window management client may be active at a time. The
 * compositor should use the unavailable event if necessary to enforce this.
 *
 * There are two disjoint categories of state managed by this protocol:
 *
 * Window management state influences the communication between the server
 * and individual window clients (e.g. xdg_toplevels). Window management
 * state includes window dimensions, fullscreen state, keyboard focus,
 * keyboard bindings, and more.
 *
 * Rendering state only affects the rendered output of the compositor and
 * does not influence communication between the server and individual window
 * clients. Rendering state includes the position and rendering order of
 * windows, shell surfaces, decoration surfaces, borders, and more.
 *
 * Window management state may only be modified by the window manager as part
 * of a manage sequence. A manage sequence is started with the manage_start
 * event and ended with the manage_finish request. It is a protocol error to
 * modify window management state outside of a manage sequence.
 *
 * A manage sequence is always followed by at least one render sequence. A
 * render sequence is started with the render_start event and ended with the
 * render_finish request.
 *
 * Rendering state may be modified by the window manager during a manage
 * sequence or a render sequence. Regardless of when the rendering state is
 * modified, it is applied with the next render_finish request. It is a
 * protocol error to modify rendering state outside of a manage or render
 * sequence.
 *
 * The server will start a manage sequence by sending new state and the
 * manage_start event as soon as possible whenever there is a change in state
 * that must be communicated with the window manager.
 *
 * If the window manager client needs to ensure a manage sequence is started
 * due to a state change the compositor is not aware of, it may send the
 * manage_dirty request.
 *
 * The server will start a render sequence by sending new state and the
 * render_start event as soon as possible whenever there is a change in
 * window dimensions that must be communicated with the window manager.
 * Multiple render sequences may be made consecutively without a manage
 * sequence in between, for example if a window independently changes its own
 * dimensions.
 *
 * To summarize, the main loop of this protocol is as follows:
 *
 * 1. The server sends events indicating all changes since the last
 * manage sequence followed by the manage_start event.
 *
 * 2. The client sends requests modifying window management state or
 * rendering state (as defined above) followed by the manage_finish
 * request.
 *
 * 3. The server sends new state to windows and waits for responses.
 *
 * 4. The server sends new window dimensions to the client followed by the
 * render_start event.
 *
 * 5. The client sends requests modifying rendering state (as defined above)
 * followed by the render_finish request.
 *
 * 6. If window dimensions change, loop back to step 4.
 * If state that requires a manage sequence changes or if the client makes
 * a manage_dirty request, loop back to step 1.
 *
 * For the purposes of frame perfection, the server may delay rendering new
 * state committed by the windows in step 3 until after step 5 is finished.
 *
 * It is a protocol error for the client to make a manage_finish or
 * render_finish request that violates this ordering.
 */
extern const struct wl_interface river_window_manager_v1_interface;
#endif
#ifndef RIVER_WINDOW_V1_INTERFACE
#define RIVER_WINDOW_V1_INTERFACE
/**
 * @page page_iface_river_window_v1 river_window_v1
 * @section page_iface_river_window_v1_desc Description
 *
 * This represents a logical window. For example, a window may correspond to
 * an xdg_toplevel or Xwayland window.
 *
 * A newly created window will not be displayed until the window manager
 * makes a propose_dimensions or fullscreen request as part of a manage
 * sequence, the server replies with a dimensions event as part of a render
 * sequence, and that render sequence is finished.
 * @section page_iface_river_window_v1_api API
 * See @ref iface_river_window_v1.
 */
/**
 * @defgroup iface_river_window_v1 The river_window_v1 interface
 *
 * This represents a logical window. For example, a window may correspond to
 * an xdg_toplevel or Xwayland window.
 *
 * A newly created window will not be displayed until the window manager
 * makes a propose_dimensions or fullscreen request as part of a manage
 * sequence, the server replies with a dimensions event as part of a render
 * sequence, and that render sequence is finished.
 */
extern const struct wl_interface river_window_v1_interface;
#endif
#ifndef RIVER_DECORATION_V1_INTERFACE
#define RIVER_DECORATION_V1_INTERFACE
/**
 * @page page_iface_river_decoration_v1 river_decoration_v1
 * @section page_iface_river_decoration_v1_desc Description
 *
 * The rendering order of windows with decorations is follows:
 *
 * 1. Decorations created with get_decoration_below at the bottom
 * 2. Window content
 * 3. Borders configured with river_window_v1.set_borders
 * 4. Decorations created with get_decoration_above at the top
 *
 * The relative ordering of decoration surfaces above/below a window is
 * undefined by this protocol and left up to the compositor.
 * @section page_iface_river_decoration_v1_api API
 * See @ref iface_river_decoration_v1.
 */
/**
 * @defgroup iface_river_decoration_v1 The river_decoration_v1 interface
 *
 * The rendering order of windows with decorations is follows:
 *
 * 1. Decorations created with get_decoration_below at the bottom
 * 2. Window content
 * 3. Borders configured with river_window_v1.set_borders
 * 4. Decorations created with get_decoration_above at the top
 *
 * The relative ordering of decoration surfaces above/below a window is
 * undefined by this protocol and left up to the compositor.
 */
extern const struct wl_interface river_decoration_v1_interface;
#endif
#ifndef RIVER_SHELL_SURFACE_V1_INTERFACE
#define RIVER_SHELL_SURFACE_V1_INTERFACE
/**
 * @page page_iface_river_shell_surface_v1 river_shell_surface_v1
 * @section page_iface_river_shell_surface_v1_desc Description
 *
 * The window manager might use a shell surface to display a status bar,
 * background image, desktop notifications, launcher, desktop menu, or
 * whatever else it wants.
 * @section page_iface_river_shell_surface_v1_api API
 * See @ref iface_river_shell_surface_v1.
 */
/**
 * @defgroup iface_river_shell_surface_v1 The river_shell_surface_v1 interface
 *
 * The window manager might use a shell surface to display a status bar,
 * background image, desktop notifications, launcher, desktop menu, or
 * whatever else it wants.
 */
extern const struct wl_interface river_shell_surface_v1_interface;
#endif
#ifndef RIVER_NODE_V1_INTERFACE
#define RIVER_NODE_V1_INTERFACE
/**
 * @page page_iface_river_node_v1 river_node_v1
 * @section page_iface_river_node_v1_desc Description
 *
 * The render list is a list of nodes that determines the rendering order of
 * the compositor. Nodes may correspond to windows or shell surfaces. The
 * relative ordering of nodes may be changed with the place_above and
 * place_below requests, changing the rendering order.
 *
 * The initial position of a node in the render list is undefined, the window
 * manager client must use the place_above or place_below request to
 * guarantee a specific rendering order.
 * @section page_iface_river_node_v1_api API
 * See @ref iface_river_node_v1.
 */
/**
 * @defgroup iface_river_node_v1 The river_node_v1 interface
 *
 * The render list is a list of nodes that determines the rendering order of
 * the compositor. Nodes may correspond to windows or shell surfaces. The
 * relative ordering of nodes may be changed with the place_above and
 * place_below requests, changing the rendering order.
 *
 * The initial position of a node in the render list is undefined, the window
 * manager client must use the place_above or place_below request to
 * guarantee a specific rendering order.
 */
extern const struct wl_interface river_node_v1_interface;
#endif
#ifndef RIVER_OUTPUT_V1_INTERFACE
#define RIVER_OUTPUT_V1_INTERFACE
/**
 * @page page_iface_river_output_v1 river_output_v1
 * @section page_iface_river_output_v1_desc Description
 *
 * An area in the compositor's logical coordinate space that should be
 * treated as a single output for window management purposes. This area may
 * correspond to a single physical output or multiple physical outputs in the
 * case of mirroring or tiled monitors depending on the hardware and
 * compositor configuration.
 * @section page_iface_river_output_v1_api API
 * See @ref iface_river_output_v1.
 */
/**
 * @defgroup iface_river_output_v1 The river_output_v1 interface
 *
 * An area in the compositor's logical coordinate space that should be
 * treated as a single output for window management purposes. This area may
 * correspond to a single physical output or multiple physical outputs in the
 * case of mirroring or tiled monitors depending on the hardware and
 * compositor configuration.
 */
extern const struct wl_interface river_output_v1_interface;
#endif
#ifndef RIVER_SEAT_V1_INTERFACE
#define RIVER_SEAT_V1_INTERFACE
/**
 * @page page_iface_river_seat_v1 river_seat_v1
 * @section page_iface_river_seat_v1_desc Description
 *
 * This object represents a single user's collection of input devices. It
 * allows the window manager to route keyboard input to windows, get
 * high-level information about pointer input, define keyboard and pointer
 * bindings, etc.
 *
 * TODO:
 * - touch input
 * - tablet input
 * @section page_iface_river_seat_v1_api API
 * See @ref iface_river_seat_v1.
 */
/**
 * @defgroup iface_river_seat_v1 The river_seat_v1 interface
 *
 * This object represents a single user's collection of input devices. It
 * allows the window manager to route keyboard input to windows, get
 * high-level information about pointer input, define keyboard and pointer
 * bindings, etc.
 *
 * TODO:
 * - touch input
 * - tablet input
 */
extern const struct wl_interface river_seat_v1_interface;
#endif
#ifndef RIVER_POINTER_BINDING_V1_INTERFACE
#define RIVER_POINTER_BINDING_V1_INTERFACE
/**
 * @page page_iface_river_pointer_binding_v1 river_pointer_binding_v1
 * @section page_iface_river_pointer_binding_v1_desc Description
 *
 * This object allows the window manager to configure a pointer binding and
 * receive events when the binding is triggered.
 *
 * The new pointer binding is not enabled until the enable request is made
 * during a manage sequence.
 *
 * Normally, all pointer button events are sent to the surface with pointer
 * focus by the compositor. Pointer button events that trigger a pointer
 * binding are not sent to the surface with pointer focus.
 *
 * If multiple pointer bindings would be triggered by a single physical
 * pointer event on the compositor side, it is compositor policy which
 * pointer binding(s) will receive press/release events or if all of the
 * matched pointer bindings receive press/release events.
 * @section page_iface_river_pointer_binding_v1_api API
 * See @ref iface_river_pointer_binding_v1.
 */
/**
 * @defgroup iface_river_pointer_binding_v1 The river_pointer_binding_v1 interface
 *
 * This object allows the window manager to configure a pointer binding and
 * receive events when the binding is triggered.
 *
 * The new pointer binding is not enabled until the enable request is made
 * during a manage sequence.
 *
 * Normally, all pointer button events are sent to the surface with pointer
 * focus by the compositor. Pointer button events that trigger a pointer
 * binding are not sent to the surface with pointer focus.
 *
 * If multiple pointer bindings would be triggered by a single physical
 * pointer event on the compositor side, it is compositor policy which
 * pointer binding(s) will receive press/release events or if all of the
 * matched pointer bindings receive press/release events.
 */
extern const struct wl_interface river_pointer_binding_v1_interface;
#endif

#ifndef RIVER_WINDOW_MANAGER_V1_ERROR_ENUM
#define RIVER_WINDOW_MANAGER_V1_ERROR_ENUM
enum river_window_manager_v1_error {
	/**
	 * request violates manage/render sequence ordering
	 */
	RIVER_WINDOW_MANAGER_V1_ERROR_SEQUENCE_ORDER = 0,
	/**
	 * given wl_surface already has a role
	 */
	RIVER_WINDOW_MANAGER_V1_ERROR_ROLE = 1,
	/**
	 * window manager unresponsive
	 */
	RIVER_WINDOW_MANAGER_V1_ERROR_UNRESPONSIVE = 2,
};
#endif /* RIVER_WINDOW_MANAGER_V1_ERROR_ENUM */

/**
 * @ingroup iface_river_window_manager_v1
 * @struct river_window_manager_v1_listener
 */
struct river_window_manager_v1_listener {
	/**
	 * window management unavailable
	 *
	 * This event indicates that window management is not available
	 * to the client, perhaps due to another window management client
	 * already running. The circumstances causing this event to be sent
	 * are compositor policy.
	 *
	 * If sent, this event is guaranteed to be the first and only event
	 * sent by the server.
	 *
	 * The server will send no further events on this object. The
	 * client should destroy this object and all objects created
	 * through this interface.
	 */
	void (*unavailable)(void *data,
			    struct river_window_manager_v1 *river_window_manager_v1);
	/**
	 * the server has finished with the window manager
	 *
	 * This event indicates that the server will send no further
	 * events on this object. The client should destroy the object. See
	 * river_window_manager_v1.destroy for more information.
	 */
	void (*finished)(void *data,
			 struct river_window_manager_v1 *river_window_manager_v1);
	/**
	 * start a manage sequence
	 *
	 * This event indicates that the server has sent events
	 * indicating all state changes since the last manage sequence.
	 *
	 * In response to this event, the client should make requests
	 * modifying window management state as it chooses. Then, the
	 * client must make the manage_finish request.
	 *
	 * See the description of the river_window_manager_v1 interface for
	 * a complete overview of the manage/render sequence loop.
	 */
	void (*manage_start)(void *data,
			     struct river_window_manager_v1 *river_window_manager_v1);
	/**
	 * start a render sequence
	 *
	 * This event indicates that the server has sent all
	 * river_node_v1.position and river_window_v1.dimensions events
	 * necessary.
	 *
	 * In response to this event, the client should make requests
	 * modifying rendering state as it chooses. Then, the client must
	 * make the render_finish request.
	 *
	 * See the description of the river_window_manager_v1 interface for
	 * a complete overview of the manage/render sequence loop.
	 */
	void (*render_start)(void *data,
			     struct river_window_manager_v1 *river_window_manager_v1);
	/**
	 * the session has been locked
	 *
	 * This event indicates that the session has been locked.
	 *
	 * The window manager may wish to restrict which key bindings are
	 * available while locked or otherwise use this information.
	 *
	 * This event will be followed by a manage_start event after all
	 * other new state has been sent by the server.
	 */
	void (*session_locked)(void *data,
			       struct river_window_manager_v1 *river_window_manager_v1);
	/**
	 * the session has been unlocked
	 *
	 * This event indicates that the session has been unlocked.
	 *
	 * This event will be followed by a manage_start event after all
	 * other new state has been sent by the server.
	 */
	void (*session_unlocked)(void *data,
				 struct river_window_manager_v1 *river_window_manager_v1);
	/**
	 * new window
	 *
	 * A new window has been created.
	 *
	 * This event will be followed by a manage_start event after all
	 * other new state has been sent by the server.
	 * @param id new window
	 */
	void (*window)(void *data,
		       struct river_window_manager_v1 *river_window_manager_v1,
		       struct river_window_v1 *id);
	/**
	 * new output
	 *
	 * A new logical output has been created, perhaps due to a new
	 * physical monitor being plugged in or perhaps due to a change in
	 * configuration.
	 *
	 * This event will be followed by river_output_v1.position and
	 * dimensions events as well as a manage_start event after all
	 * other new state has been sent by the server.
	 * @param id new output
	 */
	void (*output)(void *data,
		       struct river_window_manager_v1 *river_window_manager_v1,
		       struct river_output_v1 *id);
	/**
	 * new seat
	 *
	 * A new seat has been created.
	 *
	 * This event will be followed by a manage_start event after all
	 * other new state has been sent by the server.
	 * @param id new seat
	 */
	void (*seat)(void *data,
		     struct river_window_manager_v1 *river_window_manager_v1,
		     struct river_seat_v1 *id);
};

/**
 * @ingroup iface_river_window_manager_v1
 */
static inline int
river_window_manager_v1_add_listener(struct river_window_manager_v1 *river_window_manager_v1,
				     const struct river_window_manager_v1_listener *listener, void *data)
{
	return wl_proxy_add_listener((struct wl_proxy *) river_window_manager_v1,
				     (void (**)(void)) listener, data);
}

#define RIVER_WINDOW_MANAGER_V1_STOP 0
#define RIVER_WINDOW_MANAGER_V1_DESTROY 1
#define RIVER_WINDOW_MANAGER_V1_MANAGE_FINISH 2
#define RIVER_WINDOW_MANAGER_V1_MANAGE_DIRTY 3
#define RIVER_WINDOW_MANAGER_V1_RENDER_FINISH 4
#define RIVER_WINDOW_MANAGER_V1_GET_SHELL_SURFACE 5

/**
 * @ingroup iface_river_window_manager_v1
 */
#define RIVER_WINDOW_MANAGER_V1_UNAVAILABLE_SINCE_VERSION 1
/**
 * @ingroup iface_river_window_manager_v1
 */
#define RIVER_WINDOW_MANAGER_V1_FINISHED_SINCE_VERSION 1
/**
 * @ingroup iface_river_window_manager_v1
 */
#define RIVER_WINDOW_MANAGER_V1_MANAGE_START_SINCE_VERSION 1
/**
 * @ingroup iface_river_window_manager_v1
 */
#define RIVER_WINDOW_MANAGER_V1_RENDER_START_SINCE_VERSION 1
/**
 * @ingroup iface_river_window_manager_v1
 */
#define RIVER_WINDOW_MANAGER_V1_SESSION_LOCKED_SINCE_VERSION 1
/**
 * @ingroup iface_river_window_manager_v1
 */
#define RIVER_WINDOW_MANAGER_V1_SESSION_UNLOCKED_SINCE_VERSION 1
/**
 * @ingroup iface_river_window_manager_v1
 */
#define RIVER_WINDOW_MANAGER_V1_WINDOW_SINCE_VERSION 1
/**
 * @ingroup iface_river_window_manager_v1
 */
#define RIVER_WINDOW_MANAGER_V1_OUTPUT_SINCE_VERSION 1
/**
 * @ingroup iface_river_window_manager_v1
 */
#define RIVER_WINDOW_MANAGER_V1_SEAT_SINCE_VERSION 1

/**
 * @ingroup iface_river_window_manager_v1
 */
#define RIVER_WINDOW_MANAGER_V1_STOP_SINCE_VERSION 1
/**
 * @ingroup iface_river_window_manager_v1
 */
#define RIVER_WINDOW_MANAGER_V1_DESTROY_SINCE_VERSION 1
/**
 * @ingroup iface_river_window_manager_v1
 */
#define RIVER_WINDOW_MANAGER_V1_MANAGE_FINISH_SINCE_VERSION 1
/**
 * @ingroup iface_river_window_manager_v1
 */
#define RIVER_WINDOW_MANAGER_V1_MANAGE_DIRTY_SINCE_VERSION 1
/**
 * @ingroup iface_river_window_manager_v1
 */
#define RIVER_WINDOW_MANAGER_V1_RENDER_FINISH_SINCE_VERSION 1
/**
 * @ingroup iface_river_window_manager_v1
 */
#define RIVER_WINDOW_MANAGER_V1_GET_SHELL_SURFACE_SINCE_VERSION 1

/** @ingroup iface_river_window_manager_v1 */
static inline void
river_window_manager_v1_set_user_data(struct river_window_manager_v1 *river_window_manager_v1, void *user_data)
{
	wl_proxy_set_user_data((struct wl_proxy *) river_window_manager_v1, user_data);
}

/** @ingroup iface_river_window_manager_v1 */
static inline void *
river_window_manager_v1_get_user_data(struct river_window_manager_v1 *river_window_manager_v1)
{
	return wl_proxy_get_user_data((struct wl_proxy *) river_window_manager_v1);
}

static inline uint32_t
river_window_manager_v1_get_version(struct river_window_manager_v1 *river_window_manager_v1)
{
	return wl_proxy_get_version((struct wl_proxy *) river_window_manager_v1);
}

/**
 * @ingroup iface_river_window_manager_v1
 *
 * This request indicates that the client no longer wishes to receive
 * events on this object.
 *
 * The Wayland protocol is asynchronous, which means the server may send
 * further events until the stop request is processed. The client must wait
 * for a river_window_manager_v1.finished event before destroying this
 * object.
 */
static inline void
river_window_manager_v1_stop(struct river_window_manager_v1 *river_window_manager_v1)
{
	wl_proxy_marshal_flags((struct wl_proxy *) river_window_manager_v1,
			 RIVER_WINDOW_MANAGER_V1_STOP, NULL, wl_proxy_get_version((struct wl_proxy *) river_window_manager_v1), 0);
}

/**
 * @ingroup iface_river_window_manager_v1
 *
 * This request should be called after the finished event has been received
 * to complete destruction of the object.
 *
 * If a client wishes to destroy this object it should send a
 * river_window_manager_v1.stop request and wait for a
 * river_window_manager_v1.finished event. Once the finished event is
 * received it is safe to destroy this object and any other objects created
 * through this interface.
 */
static inline void
river_window_manager_v1_destroy(struct river_window_manager_v1 *river_window_manager_v1)
{
	wl_proxy_marshal_flags((struct wl_proxy *) river_window_manager_v1,
			 RIVER_WINDOW_MANAGER_V1_DESTROY, NULL, wl_proxy_get_version((struct wl_proxy *) river_window_manager_v1), WL_MARSHAL_FLAG_DESTROY);
}

/**
 * @ingroup iface_river_window_manager_v1
 *
 * This request indicates that the client has made all changes to window
 * management state it wishes to include in the current manage sequence and
 * that the server should atomically send these state changes to the
 * windows and continue with the manage sequence.
 *
 * After sending this request, it is a protocol error for the client to
 * make further changes to window management state until the next
 * manage_start event is received.
 *
 * See the description of the river_window_manager_v1 interface for a
 * complete overview of the manage/render sequence loop.
 */
static inline void
river_window_manager_v1_manage_finish(struct river_window_manager_v1 *river_window_manager_v1)
{
	wl_proxy_marshal_flags((struct wl_proxy *) river_window_manager_v1,
			 RIVER_WINDOW_MANAGER_V1_MANAGE_FINISH, NULL, wl_proxy_get_version((struct wl_proxy *) river_window_manager_v1), 0);
}

/**
 * @ingroup iface_river_window_manager_v1
 *
 * This request ensures a manage sequence is started and that a
 * manage_start event is sent by the server. If this request is made during
 * an ongoing manage sequence, a new manage sequence will be started as
 * soon as the current one is completed.
 *
 * The client may want to use this request due to an internal state change
 * that the compositor is not aware of (e.g. a dbus event) which should
 * affect window management or rendering state.
 */
static inline void
river_window_manager_v1_manage_dirty(struct river_window_manager_v1 *river_window_manager_v1)
{
	wl_proxy_marshal_flags((struct wl_proxy *) river_window_manager_v1,
			 RIVER_WINDOW_MANAGER_V1_MANAGE_DIRTY, NULL, wl_proxy_get_version((struct wl_proxy *) river_window_manager_v1), 0);
}

/**
 * @ingroup iface_river_window_manager_v1
 *
 * This request indicates that the client has made all changes to rendering
 * state it wishes to include in the current manage sequence and that the
 * server should atomically apply and display these state changes to the
 * user.
 *
 * After sending this request, it is a protocol error for the client to
 * make further changes to rendering state until the next manage_start or
 * render_start event is received, whichever comes first.
 *
 * See the description of the river_window_manager_v1 interface for a
 * complete overview of the manage/render sequence loop.
 */
static inline void
river_window_manager_v1_render_finish(struct river_window_manager_v1 *river_window_manager_v1)
{
	wl_proxy_marshal_flags((struct wl_proxy *) river_window_manager_v1,
			 RIVER_WINDOW_MANAGER_V1_RENDER_FINISH, NULL, wl_proxy_get_version((struct wl_proxy *) river_window_manager_v1), 0);
}

/**
 * @ingroup iface_river_window_manager_v1
 *
 * Create a new shell surface for window manager UI and assign the
 * river_shell_surface_v1 role to the surface.
 *
 * Providing a wl_surface which already has a role or already has a buffer
 * attached or committed is a protocol error.
 */
static inline struct river_shell_surface_v1 *
river_window_manager_v1_get_shell_surface(struct river_window_manager_v1 *river_window_manager_v1, struct wl_surface *surface)
{
	struct wl_proxy *id;

	id = wl_proxy_marshal_flags((struct wl_proxy *) river_window_manager_v1,
			 RIVER_WINDOW_MANAGER_V1_GET_SHELL_SURFACE, &river_shell_surface_v1_interface, wl_proxy_get_version((struct wl_proxy *) river_window_manager_v1), 0, NULL, surface);

	return (struct river_shell_surface_v1 *) id;
}

#ifndef RIVER_WINDOW_V1_ERROR_ENUM
#define RIVER_WINDOW_V1_ERROR_ENUM
enum river_window_v1_error {
	/**
	 * window already has a node object
	 */
	RIVER_WINDOW_V1_ERROR_NODE_EXISTS = 0,
	/**
	 * proposed dimensions out of bounds
	 */
	RIVER_WINDOW_V1_ERROR_INVALID_DIMENSIONS = 1,
	/**
	 * invalid arg to set_borders
	 */
	RIVER_WINDOW_V1_ERROR_INVALID_BORDER = 2,
	/**
	 * invalid arg to set_clip_box
	 */
	RIVER_WINDOW_V1_ERROR_INVALID_CLIP_BOX = 3,
};
#endif /* RIVER_WINDOW_V1_ERROR_ENUM */

#ifndef RIVER_WINDOW_V1_DECORATION_HINT_ENUM
#define RIVER_WINDOW_V1_DECORATION_HINT_ENUM
enum river_window_v1_decoration_hint {
	/**
	 * only supports client side decoration
	 */
	RIVER_WINDOW_V1_DECORATION_HINT_ONLY_SUPPORTS_CSD = 0,
	/**
	 * client side decoration preferred, both CSD and SSD supported
	 */
	RIVER_WINDOW_V1_DECORATION_HINT_PREFERS_CSD = 1,
	/**
	 * server side decoration preferred, both CSD and SSD supported
	 */
	RIVER_WINDOW_V1_DECORATION_HINT_PREFERS_SSD = 2,
	/**
	 * no preference, both CSD and SSD supported
	 */
	RIVER_WINDOW_V1_DECORATION_HINT_NO_PREFERENCE = 3,
};
#endif /* RIVER_WINDOW_V1_DECORATION_HINT_ENUM */

#ifndef RIVER_WINDOW_V1_EDGES_ENUM
#define RIVER_WINDOW_V1_EDGES_ENUM
enum river_window_v1_edges {
	RIVER_WINDOW_V1_EDGES_NONE = 0,
	RIVER_WINDOW_V1_EDGES_TOP = 1,
	RIVER_WINDOW_V1_EDGES_BOTTOM = 2,
	RIVER_WINDOW_V1_EDGES_LEFT = 4,
	RIVER_WINDOW_V1_EDGES_RIGHT = 8,
};
#endif /* RIVER_WINDOW_V1_EDGES_ENUM */

#ifndef RIVER_WINDOW_V1_CAPABILITIES_ENUM
#define RIVER_WINDOW_V1_CAPABILITIES_ENUM
enum river_window_v1_capabilities {
	RIVER_WINDOW_V1_CAPABILITIES_WINDOW_MENU = 1,
	RIVER_WINDOW_V1_CAPABILITIES_MAXIMIZE = 2,
	RIVER_WINDOW_V1_CAPABILITIES_FULLSCREEN = 4,
	RIVER_WINDOW_V1_CAPABILITIES_MINIMIZE = 8,
};
#endif /* RIVER_WINDOW_V1_CAPABILITIES_ENUM */

/**
 * @ingroup iface_river_window_v1
 * @struct river_window_v1_listener
 */
struct river_window_v1_listener {
	/**
	 * the window has been closed
	 *
	 * The window has been closed by the server, perhaps due to an
	 * xdg_toplevel.close request or similar.
	 *
	 * The server will send no further events on this object and ignore
	 * any request other than river_window_v1.destroy made after this
	 * event is sent. The client should destroy this object with the
	 * river_window_v1.destroy request to free up resources.
	 *
	 * This event will be followed by a manage_start event after all
	 * other new state has been sent by the server.
	 */
	void (*closed)(void *data,
		       struct river_window_v1 *river_window_v1);
	/**
	 * the window's preferred min/max dimensions
	 *
	 * This event informs the window manager of the window's
	 * preferred min/max dimensions. These preferences are a hint, and
	 * the window manager is free to propose dimensions outside of
	 * these bounds.
	 *
	 * All min/max width/height values must be strictly greater than or
	 * equal to 0. A value of 0 indicates that the window has no
	 * preference for that value.
	 *
	 * The min_width/min_height must be strictly less than or equal to
	 * the max_width/max_height.
	 *
	 * This event will be followed by a manage_start event after all
	 * other new state has been sent by the server.
	 * @param min_width minimum width
	 * @param min_height minimum height
	 * @param max_width maximum width
	 * @param max_height maximum height
	 */
	void (*dimensions_hint)(void *data,
				struct river_window_v1 *river_window_v1,
				int32_t min_width,
				int32_t min_height,
				int32_t max_width,
				int32_t max_height);
	/**
	 * window dimensions
	 *
	 * This event indicates the dimensions of the window in the
	 * compositor's logical coordinate space. The width and height must
	 * be strictly greater than zero.
	 *
	 * Note that the dimensions of a river_window_v1 refer to the
	 * dimensions of the window content and are unaffected by the
	 * presence of borders or decoration surfaces.
	 *
	 * This event is sent as part of a render sequence before the
	 * render_start event.
	 *
	 * It may be sent due to a propose_dimensions or fullscreen request
	 * in a previous manage sequence or because a window independently
	 * decides to change its dimensions.
	 *
	 * The window will not be displayed until the first dimensions
	 * event is received and the render sequence is finished.
	 * @param width window content width
	 * @param height window content height
	 */
	void (*dimensions)(void *data,
			   struct river_window_v1 *river_window_v1,
			   int32_t width,
			   int32_t height);
	/**
	 * the window set an application ID
	 *
	 * The window set an application ID.
	 *
	 * The app_id argument will be null if the window has never set an
	 * application ID or if the window cleared its application ID.
	 * (Xwayland windows may do this for example, though xdg-toplevels
	 * may not.)
	 *
	 * This event will be followed by a manage_start event after all
	 * other new state has been sent by the server.
	 * @param app_id window application ID
	 */
	void (*app_id)(void *data,
		       struct river_window_v1 *river_window_v1,
		       const char *app_id);
	/**
	 * the window set a title
	 *
	 * The window set a title.
	 *
	 * The title argument will be null if the window has never set a
	 * title or if the window cleared its title. (Xwayland windows may
	 * do this for example, though xdg-toplevels may not.)
	 *
	 * This event will be followed by a manage_start event after all
	 * other new state has been sent by the server.
	 * @param title window title
	 */
	void (*title)(void *data,
		      struct river_window_v1 *river_window_v1,
		      const char *title);
	/**
	 * the window set a parent
	 *
	 * The window set a parent window. If this event is never
	 * received or if the parent argument is null then the window has
	 * no parent.
	 *
	 * A surface with a parent set might be a dialog, file picker, or
	 * similar for the parent window.
	 *
	 * Child windows should generally be rendered directly above their
	 * parent.
	 *
	 * The compositor must guarantee that there are no loops in the
	 * window tree: a parent must not be the descendant of one of its
	 * children.
	 *
	 * This event will be followed by a manage_start event after all
	 * other new state has been sent by the server.
	 * @param parent parent window, if any
	 */
	void (*parent)(void *data,
		       struct river_window_v1 *river_window_v1,
		       struct river_window_v1 *parent);
	/**
	 * supported/preferred decoration style
	 *
	 * Information from the window about the supported and preferred
	 * client side/server side decoration options.
	 *
	 * This event may be sent multiple times over the lifetime of the
	 * window if the window changes its preferences.
	 *
	 * This event will be followed by a manage_start event after all
	 * other new state has been sent by the server.
	 * @param hint decoration hint
	 */
	void (*decoration_hint)(void *data,
				struct river_window_v1 *river_window_v1,
				uint32_t hint);
	/**
	 * window requested interactive pointer move
	 *
	 * This event informs the window manager that the window has
	 * requested to be interactively moved using the pointer. The seat
	 * argument indicates the seat for the move.
	 *
	 * The xdg-shell protocol for example allows windows to request
	 * that an interactive move be started, perhaps when a client-side
	 * rendered titlebar is dragged.
	 *
	 * The window manager may use the river_seat_v1.op_start_pointer
	 * request to interactively move the window or ignore this event
	 * entirely.
	 *
	 * This event will be followed by a manage_start event after all
	 * other new state has been sent by the server.
	 * @param seat requested seat
	 */
	void (*pointer_move_requested)(void *data,
				       struct river_window_v1 *river_window_v1,
				       struct river_seat_v1 *seat);
	/**
	 * window requested interactive pointer resize
	 *
	 * This event informs the window manager that the window has
	 * requested to be interactively resized using the pointer. The
	 * seat argument indicates the seat for the resize.
	 *
	 * The edges argument indicates which edges the window has
	 * requested to be resized from. The edges argument will never be
	 * none and will never have both top and bottom or both left and
	 * right edges set.
	 *
	 * The xdg-shell protocol for example allows windows to request
	 * that an interactive resize be started, perhaps when the corner
	 * of client-side rendered decorations is dragged.
	 *
	 * The window manager may use the river_seat_v1.op_start_pointer
	 * request to interactively resize the window or ignore this event
	 * entirely.
	 *
	 * This event will be followed by a manage_start event after all
	 * other new state has been sent by the server.
	 * @param seat requested seat
	 * @param edges requested edges
	 */
	void (*pointer_resize_requested)(void *data,
					 struct river_window_v1 *river_window_v1,
					 struct river_seat_v1 *seat,
					 uint32_t edges);
	/**
	 * window requested that the window menu be shown
	 *
	 * The xdg-shell protocol for example allows windows to request
	 * that a window menu be shown, for example when the user right
	 * clicks on client side window decorations.
	 *
	 * A window menu might include options to maximize or minimize the
	 * window.
	 *
	 * The window manager is free to ignore this request and decide
	 * what the window menu contains if it does choose to show one.
	 *
	 * The x and y arguments indicate where the window requested that
	 * the window menu be shown.
	 *
	 * This event will be followed by a manage_start event after all
	 * other new state has been sent by the server.
	 * @param x x offset from top left corner
	 * @param y y offset from top left corner
	 */
	void (*show_window_menu_requested)(void *data,
					   struct river_window_v1 *river_window_v1,
					   int32_t x,
					   int32_t y);
	/**
	 * the window requested to be maximized
	 *
	 * The xdg-shell protocol for example allows windows to request
	 * to be maximized.
	 *
	 * The window manager is free to honor this request using
	 * river_window_v1.inform_maximize or ignore it.
	 *
	 * This event will be followed by a manage_start event after all
	 * other new state has been sent by the server.
	 */
	void (*maximize_requested)(void *data,
				   struct river_window_v1 *river_window_v1);
	/**
	 * the window requested to be unmaximized
	 *
	 * The xdg-shell protocol for example allows windows to request
	 * to be unmaximized.
	 *
	 * The window manager is free to honor this request using
	 * river_window_v1.inform_unmaximized or ignore it.
	 *
	 * This event will be followed by a manage_start event after all
	 * other new state has been sent by the server.
	 */
	void (*unmaximize_requested)(void *data,
				     struct river_window_v1 *river_window_v1);
	/**
	 * the window requested to be fullscreen
	 *
	 * The xdg-shell protocol for example allows windows to request
	 * that they be made fullscreen and allows them to provide an
	 * output preference.
	 *
	 * The window manager is free to honor this request using
	 * river_window_v1.fullscreen or ignore it.
	 *
	 * This event will be followed by a manage_start event after all
	 * other new state has been sent by the server.
	 * @param output fullscreen output requested
	 */
	void (*fullscreen_requested)(void *data,
				     struct river_window_v1 *river_window_v1,
				     struct river_output_v1 *output);
	/**
	 * the window requested to exit fullscreen
	 *
	 * The xdg-shell protocol for example allows windows to request
	 * to exit fullscreen.
	 *
	 * The window manager is free to honor this request using
	 * river_window_v1.exit_fullscreen or ignore it.
	 *
	 * This event will be followed by a manage_start event after all
	 * other new state has been sent by the server.
	 */
	void (*exit_fullscreen_requested)(void *data,
					  struct river_window_v1 *river_window_v1);
	/**
	 * the window requested to be minimized
	 *
	 * The xdg-shell protocol for example allows windows to request
	 * to be minimized.
	 *
	 * The window manager is free to ignore this request, hide the
	 * window, or do whatever else it chooses.
	 *
	 * This event will be followed by a manage_start event after all
	 * other new state has been sent by the server.
	 */
	void (*minimize_requested)(void *data,
				   struct river_window_v1 *river_window_v1);
	/**
	 * unreliable PID of the window's creator
	 *
	 * This event gives an unreliable PID of the process that created
	 * the window. Obtaining this information is inherently racy due to
	 * PID reuse. Therefore, this PID must not be used for anything
	 * security sensitive.
	 *
	 * Note also that a single process may create multiple windows, so
	 * there is not necessarily a 1-to-1 mapping from PID to window.
	 * Multiple windows may have the same PID.
	 *
	 * This event is sent once when the river_window_v1 is created and
	 * never sent again.
	 * @param unreliable_pid unreliable PID
	 * @since 2
	 */
	void (*unreliable_pid)(void *data,
			       struct river_window_v1 *river_window_v1,
			       int32_t unreliable_pid);
};

/**
 * @ingroup iface_river_window_v1
 */
static inline int
river_window_v1_add_listener(struct river_window_v1 *river_window_v1,
			     const struct river_window_v1_listener *listener, void *data)
{
	return wl_proxy_add_listener((struct wl_proxy *) river_window_v1,
				     (void (**)(void)) listener, data);
}

#define RIVER_WINDOW_V1_DESTROY 0
#define RIVER_WINDOW_V1_CLOSE 1
#define RIVER_WINDOW_V1_GET_NODE 2
#define RIVER_WINDOW_V1_PROPOSE_DIMENSIONS 3
#define RIVER_WINDOW_V1_HIDE 4
#define RIVER_WINDOW_V1_SHOW 5
#define RIVER_WINDOW_V1_USE_CSD 6
#define RIVER_WINDOW_V1_USE_SSD 7
#define RIVER_WINDOW_V1_SET_BORDERS 8
#define RIVER_WINDOW_V1_SET_TILED 9
#define RIVER_WINDOW_V1_GET_DECORATION_ABOVE 10
#define RIVER_WINDOW_V1_GET_DECORATION_BELOW 11
#define RIVER_WINDOW_V1_INFORM_RESIZE_START 12
#define RIVER_WINDOW_V1_INFORM_RESIZE_END 13
#define RIVER_WINDOW_V1_SET_CAPABILITIES 14
#define RIVER_WINDOW_V1_INFORM_MAXIMIZED 15
#define RIVER_WINDOW_V1_INFORM_UNMAXIMIZED 16
#define RIVER_WINDOW_V1_INFORM_FULLSCREEN 17
#define RIVER_WINDOW_V1_INFORM_NOT_FULLSCREEN 18
#define RIVER_WINDOW_V1_FULLSCREEN 19
#define RIVER_WINDOW_V1_EXIT_FULLSCREEN 20
#define RIVER_WINDOW_V1_SET_CLIP_BOX 21
#define RIVER_WINDOW_V1_SET_CONTENT_CLIP_BOX 22

/**
 * @ingroup iface_river_window_v1
 */
#define RIVER_WINDOW_V1_CLOSED_SINCE_VERSION 1
/**
 * @ingroup iface_river_window_v1
 */
#define RIVER_WINDOW_V1_DIMENSIONS_HINT_SINCE_VERSION 1
/**
 * @ingroup iface_river_window_v1
 */
#define RIVER_WINDOW_V1_DIMENSIONS_SINCE_VERSION 1
/**
 * @ingroup iface_river_window_v1
 */
#define RIVER_WINDOW_V1_APP_ID_SINCE_VERSION 1
/**
 * @ingroup iface_river_window_v1
 */
#define RIVER_WINDOW_V1_TITLE_SINCE_VERSION 1
/**
 * @ingroup iface_river_window_v1
 */
#define RIVER_WINDOW_V1_PARENT_SINCE_VERSION 1
/**
 * @ingroup iface_river_window_v1
 */
#define RIVER_WINDOW_V1_DECORATION_HINT_SINCE_VERSION 1
/**
 * @ingroup iface_river_window_v1
 */
#define RIVER_WINDOW_V1_POINTER_MOVE_REQUESTED_SINCE_VERSION 1
/**
 * @ingroup iface_river_window_v1
 */
#define RIVER_WINDOW_V1_POINTER_RESIZE_REQUESTED_SINCE_VERSION 1
/**
 * @ingroup iface_river_window_v1
 */
#define RIVER_WINDOW_V1_SHOW_WINDOW_MENU_REQUESTED_SINCE_VERSION 1
/**
 * @ingroup iface_river_window_v1
 */
#define RIVER_WINDOW_V1_MAXIMIZE_REQUESTED_SINCE_VERSION 1
/**
 * @ingroup iface_river_window_v1
 */
#define RIVER_WINDOW_V1_UNMAXIMIZE_REQUESTED_SINCE_VERSION 1
/**
 * @ingroup iface_river_window_v1
 */
#define RIVER_WINDOW_V1_FULLSCREEN_REQUESTED_SINCE_VERSION 1
/**
 * @ingroup iface_river_window_v1
 */
#define RIVER_WINDOW_V1_EXIT_FULLSCREEN_REQUESTED_SINCE_VERSION 1
/**
 * @ingroup iface_river_window_v1
 */
#define RIVER_WINDOW_V1_MINIMIZE_REQUESTED_SINCE_VERSION 1
/**
 * @ingroup iface_river_window_v1
 */
#define RIVER_WINDOW_V1_UNRELIABLE_PID_SINCE_VERSION 2

/**
 * @ingroup iface_river_window_v1
 */
#define RIVER_WINDOW_V1_DESTROY_SINCE_VERSION 1
/**
 * @ingroup iface_river_window_v1
 */
#define RIVER_WINDOW_V1_CLOSE_SINCE_VERSION 1
/**
 * @ingroup iface_river_window_v1
 */
#define RIVER_WINDOW_V1_GET_NODE_SINCE_VERSION 1
/**
 * @ingroup iface_river_window_v1
 */
#define RIVER_WINDOW_V1_PROPOSE_DIMENSIONS_SINCE_VERSION 1
/**
 * @ingroup iface_river_window_v1
 */
#define RIVER_WINDOW_V1_HIDE_SINCE_VERSION 1
/**
 * @ingroup iface_river_window_v1
 */
#define RIVER_WINDOW_V1_SHOW_SINCE_VERSION 1
/**
 * @ingroup iface_river_window_v1
 */
#define RIVER_WINDOW_V1_USE_CSD_SINCE_VERSION 1
/**
 * @ingroup iface_river_window_v1
 */
#define RIVER_WINDOW_V1_USE_SSD_SINCE_VERSION 1
/**
 * @ingroup iface_river_window_v1
 */
#define RIVER_WINDOW_V1_SET_BORDERS_SINCE_VERSION 1
/**
 * @ingroup iface_river_window_v1
 */
#define RIVER_WINDOW_V1_SET_TILED_SINCE_VERSION 1
/**
 * @ingroup iface_river_window_v1
 */
#define RIVER_WINDOW_V1_GET_DECORATION_ABOVE_SINCE_VERSION 1
/**
 * @ingroup iface_river_window_v1
 */
#define RIVER_WINDOW_V1_GET_DECORATION_BELOW_SINCE_VERSION 1
/**
 * @ingroup iface_river_window_v1
 */
#define RIVER_WINDOW_V1_INFORM_RESIZE_START_SINCE_VERSION 1
/**
 * @ingroup iface_river_window_v1
 */
#define RIVER_WINDOW_V1_INFORM_RESIZE_END_SINCE_VERSION 1
/**
 * @ingroup iface_river_window_v1
 */
#define RIVER_WINDOW_V1_SET_CAPABILITIES_SINCE_VERSION 1
/**
 * @ingroup iface_river_window_v1
 */
#define RIVER_WINDOW_V1_INFORM_MAXIMIZED_SINCE_VERSION 1
/**
 * @ingroup iface_river_window_v1
 */
#define RIVER_WINDOW_V1_INFORM_UNMAXIMIZED_SINCE_VERSION 1
/**
 * @ingroup iface_river_window_v1
 */
#define RIVER_WINDOW_V1_INFORM_FULLSCREEN_SINCE_VERSION 1
/**
 * @ingroup iface_river_window_v1
 */
#define RIVER_WINDOW_V1_INFORM_NOT_FULLSCREEN_SINCE_VERSION 1
/**
 * @ingroup iface_river_window_v1
 */
#define RIVER_WINDOW_V1_FULLSCREEN_SINCE_VERSION 1
/**
 * @ingroup iface_river_window_v1
 */
#define RIVER_WINDOW_V1_EXIT_FULLSCREEN_SINCE_VERSION 1
/**
 * @ingroup iface_river_window_v1
 */
#define RIVER_WINDOW_V1_SET_CLIP_BOX_SINCE_VERSION 2
/**
 * @ingroup iface_river_window_v1
 */
#define RIVER_WINDOW_V1_SET_CONTENT_CLIP_BOX_SINCE_VERSION 3

/** @ingroup iface_river_window_v1 */
static inline void
river_window_v1_set_user_data(struct river_window_v1 *river_window_v1, void *user_data)
{
	wl_proxy_set_user_data((struct wl_proxy *) river_window_v1, user_data);
}

/** @ingroup iface_river_window_v1 */
static inline void *
river_window_v1_get_user_data(struct river_window_v1 *river_window_v1)
{
	return wl_proxy_get_user_data((struct wl_proxy *) river_window_v1);
}

static inline uint32_t
river_window_v1_get_version(struct river_window_v1 *river_window_v1)
{
	return wl_proxy_get_version((struct wl_proxy *) river_window_v1);
}

/**
 * @ingroup iface_river_window_v1
 *
 * This request indicates that the client will no longer use the window
 * object and that it may be safely destroyed.
 *
 * This request should be made after the river_window_v1.closed event or
 * river_window_manager_v1.finished is received to complete destruction of
 * the window.
 */
static inline void
river_window_v1_destroy(struct river_window_v1 *river_window_v1)
{
	wl_proxy_marshal_flags((struct wl_proxy *) river_window_v1,
			 RIVER_WINDOW_V1_DESTROY, NULL, wl_proxy_get_version((struct wl_proxy *) river_window_v1), WL_MARSHAL_FLAG_DESTROY);
}

/**
 * @ingroup iface_river_window_v1
 *
 * Request that the window be closed. The window may ignore this request or
 * only close after some delay, perhaps opening a dialog asking the user to
 * save their work or similar.
 *
 * The server will send a river_window_v1.closed event if/when the window
 * has been closed.
 *
 * This request modifies window management state and may only be made as
 * part of a manage sequence, see the river_window_manager_v1 description.
 */
static inline void
river_window_v1_close(struct river_window_v1 *river_window_v1)
{
	wl_proxy_marshal_flags((struct wl_proxy *) river_window_v1,
			 RIVER_WINDOW_V1_CLOSE, NULL, wl_proxy_get_version((struct wl_proxy *) river_window_v1), 0);
}

/**
 * @ingroup iface_river_window_v1
 *
 * Get the node in the render list corresponding to the window.
 *
 * It is a protocol error to make this request more than once for a single
 * window.
 */
static inline struct river_node_v1 *
river_window_v1_get_node(struct river_window_v1 *river_window_v1)
{
	struct wl_proxy *id;

	id = wl_proxy_marshal_flags((struct wl_proxy *) river_window_v1,
			 RIVER_WINDOW_V1_GET_NODE, &river_node_v1_interface, wl_proxy_get_version((struct wl_proxy *) river_window_v1), 0, NULL);

	return (struct river_node_v1 *) id;
}

/**
 * @ingroup iface_river_window_v1
 *
 * This request proposes dimensions for the window in the compositor's
 * logical coordinate space.
 *
 * The width and height must be greater than or equal to zero. If the width
 * or height is zero the window will be allowed to decide its own
 * dimensions.
 *
 * The window may not take the exact dimensions proposed. The actual
 * dimensions taken by the window will be sent in a subsequent
 * river_window_v1.dimensions event. For example, a terminal emulator may
 * only allow dimensions that are multiple of the cell size.
 *
 * When a propose_dimensions request is made, the server must send a
 * dimensions event in response as soon as possible. It may not be possible
 * to send a dimensions event in the very next render sequence if, for
 * example, the window takes too long to respond to the proposed
 * dimensions. In this case, the server will send the dimensions event in a
 * future render sequence.
 *
 * Note that the dimensions of a river_window_v1 refer to the dimensions of
 * the window content and are unaffected by the presence of borders or
 * decoration surfaces.
 *
 * This request modifies window management state and may only be made as
 * part of a manage sequence, see the river_window_manager_v1 description.
 */
static inline void
river_window_v1_propose_dimensions(struct river_window_v1 *river_window_v1, int32_t width, int32_t height)
{
	wl_proxy_marshal_flags((struct wl_proxy *) river_window_v1,
			 RIVER_WINDOW_V1_PROPOSE_DIMENSIONS, NULL, wl_proxy_get_version((struct wl_proxy *) river_window_v1), 0, width, height);
}

/**
 * @ingroup iface_river_window_v1
 *
 * Request that the window be hidden. Has no effect if the window is
 * already hidden. Hides any window borders and decorations as well.
 *
 * Newly created windows are considered shown unless explicitly hidden with
 * the hide request.
 *
 * This request modifies rendering state and may only be made as part of a
 * render sequence, see the river_window_manager_v1 description.
 */
static inline void
river_window_v1_hide(struct river_window_v1 *river_window_v1)
{
	wl_proxy_marshal_flags((struct wl_proxy *) river_window_v1,
			 RIVER_WINDOW_V1_HIDE, NULL, wl_proxy_get_version((struct wl_proxy *) river_window_v1), 0);
}

/**
 * @ingroup iface_river_window_v1
 *
 * Request that the window be shown. Has no effect if the window is not
 * hidden. Does not guarantee that the window is visible as it may be
 * completely obscured by other windows placed above it for example.
 *
 * Newly created windows are considered shown unless explicitly hidden with
 * the hide request.
 *
 * This request modifies rendering state and may only be made as part of a
 * render sequence, see the river_window_manager_v1 description.
 */
static inline void
river_window_v1_show(struct river_window_v1 *river_window_v1)
{
	wl_proxy_marshal_flags((struct wl_proxy *) river_window_v1,
			 RIVER_WINDOW_V1_SHOW, NULL, wl_proxy_get_version((struct wl_proxy *) river_window_v1), 0);
}

/**
 * @ingroup iface_river_window_v1
 *
 * Tell the client to use client side decoration and draw its own title
 * bar, borders, etc.
 *
 * This is the default if neither this request nor the use_ssd request is
 * ever made.
 *
 * This request modifies window management state and may only be made as
 * part of a manage sequence, see the river_window_manager_v1 description.
 */
static inline void
river_window_v1_use_csd(struct river_window_v1 *river_window_v1)
{
	wl_proxy_marshal_flags((struct wl_proxy *) river_window_v1,
			 RIVER_WINDOW_V1_USE_CSD, NULL, wl_proxy_get_version((struct wl_proxy *) river_window_v1), 0);
}

/**
 * @ingroup iface_river_window_v1
 *
 * Tell the client to use server side decoration and not draw any client
 * side decorations.
 *
 * This request will have no effect if the client only supports client side
 * decoration, see the decoration_hint event.
 *
 * This request modifies window management state and may only be made as
 * part of a manage sequence, see the river_window_manager_v1 description.
 */
static inline void
river_window_v1_use_ssd(struct river_window_v1 *river_window_v1)
{
	wl_proxy_marshal_flags((struct wl_proxy *) river_window_v1,
			 RIVER_WINDOW_V1_USE_SSD, NULL, wl_proxy_get_version((struct wl_proxy *) river_window_v1), 0);
}

/**
 * @ingroup iface_river_window_v1
 *
 * This request decorates the window with borders drawn by the compositor
 * on the specified edges of the window. Borders are drawn above the window
 * content.
 *
 * Corners are drawn only between borders on adjacent edges. If e.g. the
 * left edge has a border and the top edge does not, the border drawn on
 * the left edge will not extend vertically beyond the top edge of the
 * window.
 *
 * Borders are not drawn while the window is fullscreen.
 *
 * The color is defined by four 32-bit RGBA values. Unless specified in
 * another protocol extension, the RGBA values use pre-multiplied alpha.
 *
 * Setting the edges to none or the width to 0 disables the borders.
 * Setting a negative width is a protocol error.
 *
 * This request completely overrides all previous set_borders requests.
 * Only the most recent set_borders request has an effect.
 *
 * Note that the position/dimensions of a river_window_v1 refer to the
 * position/dimensions of the window content and are unaffected by the
 * presence of borders or decoration surfaces.
 *
 * This request modifies rendering state and may only be made as part of a
 * render sequence, see the river_window_manager_v1 description.
 */
static inline void
river_window_v1_set_borders(struct river_window_v1 *river_window_v1, uint32_t edges, int32_t width, uint32_t r, uint32_t g, uint32_t b, uint32_t a)
{
	wl_proxy_marshal_flags((struct wl_proxy *) river_window_v1,
			 RIVER_WINDOW_V1_SET_BORDERS, NULL, wl_proxy_get_version((struct wl_proxy *) river_window_v1), 0, edges, width, r, g, b, a);
}

/**
 * @ingroup iface_river_window_v1
 *
 * Inform the window that it is part of a tiled layout and adjacent to
 * other elements in the tiled layout on the given edges.
 *
 * The window should use this information to change the style of its client
 * side decorations and avoid drawing e.g. drop shadows outside of the
 * window dimensions on the tiled edges.
 *
 * Setting the edges argument to none informs the window that it is not
 * part of a tiled layout. If this request is never made, the window is
 * informed that it is not part of a tiled layout.
 *
 * This request modifies window management state and may only be made as
 * part of a manage sequence, see the river_window_manager_v1 description.
 */
static inline void
river_window_v1_set_tiled(struct river_window_v1 *river_window_v1, uint32_t edges)
{
	wl_proxy_marshal_flags((struct wl_proxy *) river_window_v1,
			 RIVER_WINDOW_V1_SET_TILED, NULL, wl_proxy_get_version((struct wl_proxy *) river_window_v1), 0, edges);
}

/**
 * @ingroup iface_river_window_v1
 *
 * Create a decoration surface and assign the river_decoration_v1 role to
 * the surface. The created decoration is placed above the window in
 * rendering order, see the description of river_decoration_v1.
 *
 * Providing a wl_surface which already has a role or already has a buffer
 * attached or committed is a protocol error.
 */
static inline struct river_decoration_v1 *
river_window_v1_get_decoration_above(struct river_window_v1 *river_window_v1, struct wl_surface *surface)
{
	struct wl_proxy *id;

	id = wl_proxy_marshal_flags((struct wl_proxy *) river_window_v1,
			 RIVER_WINDOW_V1_GET_DECORATION_ABOVE, &river_decoration_v1_interface, wl_proxy_get_version((struct wl_proxy *) river_window_v1), 0, NULL, surface);

	return (struct river_decoration_v1 *) id;
}

/**
 * @ingroup iface_river_window_v1
 *
 * Create a decoration surface and assign the river_decoration_v1 role to
 * the surface. The created decoration is placed below the window in
 * rendering order, see the description of river_decoration_v1.
 *
 * Providing a wl_surface which already has a role or already has a buffer
 * attached or committed is a protocol error.
 */
static inline struct river_decoration_v1 *
river_window_v1_get_decoration_below(struct river_window_v1 *river_window_v1, struct wl_surface *surface)
{
	struct wl_proxy *id;

	id = wl_proxy_marshal_flags((struct wl_proxy *) river_window_v1,
			 RIVER_WINDOW_V1_GET_DECORATION_BELOW, &river_decoration_v1_interface, wl_proxy_get_version((struct wl_proxy *) river_window_v1), 0, NULL, surface);

	return (struct river_decoration_v1 *) id;
}

/**
 * @ingroup iface_river_window_v1
 *
 * Inform the window that it is being resized. The window manager should
 * use this request to inform windows that are the target of an interactive
 * resize for example.
 *
 * The window manager remains responsible for handling the position and
 * dimensions of the window while it is resizing.
 *
 * This request modifies window management state and may only be made as
 * part of a manage sequence, see the river_window_manager_v1 description.
 */
static inline void
river_window_v1_inform_resize_start(struct river_window_v1 *river_window_v1)
{
	wl_proxy_marshal_flags((struct wl_proxy *) river_window_v1,
			 RIVER_WINDOW_V1_INFORM_RESIZE_START, NULL, wl_proxy_get_version((struct wl_proxy *) river_window_v1), 0);
}

/**
 * @ingroup iface_river_window_v1
 *
 * Inform the window that it is no longer being resized. The window manager
 * should use this request to inform windows that are the target of an
 * interactive resize that the interactive resize has ended for example.
 *
 * This request modifies window management state and may only be made as
 * part of a manage sequence, see the river_window_manager_v1 description.
 */
static inline void
river_window_v1_inform_resize_end(struct river_window_v1 *river_window_v1)
{
	wl_proxy_marshal_flags((struct wl_proxy *) river_window_v1,
			 RIVER_WINDOW_V1_INFORM_RESIZE_END, NULL, wl_proxy_get_version((struct wl_proxy *) river_window_v1), 0);
}

/**
 * @ingroup iface_river_window_v1
 *
 * This request informs the window of the capabilities supported by the
 * window manager. If the window manager, for example, ignores requests to
 * be maximized from the window it should not tell the window that it
 * supports the maximize capability.
 *
 * The window might use this information to, for example, only show a
 * maximize button if the window manager supports the maximize capability.
 *
 * The window manager client should use this request to set capabilities
 * for all new windows. If this request is never made, the compositor will
 * inform windows that all capabilities are supported.
 *
 * This request modifies window management state and may only be made as
 * part of a manage sequence, see the river_window_manager_v1 description.
 */
static inline void
river_window_v1_set_capabilities(struct river_window_v1 *river_window_v1, uint32_t caps)
{
	wl_proxy_marshal_flags((struct wl_proxy *) river_window_v1,
			 RIVER_WINDOW_V1_SET_CAPABILITIES, NULL, wl_proxy_get_version((struct wl_proxy *) river_window_v1), 0, caps);
}

/**
 * @ingroup iface_river_window_v1
 *
 * Inform the window that it is maximized. The window might use this
 * information to adapt the style of its client-side window decorations for
 * example.
 *
 * The window manager remains responsible for handling the position and
 * dimensions of the window while it is maximized.
 *
 * This request modifies window management state and may only be made as
 * part of a manage sequence, see the river_window_manager_v1 description.
 */
static inline void
river_window_v1_inform_maximized(struct river_window_v1 *river_window_v1)
{
	wl_proxy_marshal_flags((struct wl_proxy *) river_window_v1,
			 RIVER_WINDOW_V1_INFORM_MAXIMIZED, NULL, wl_proxy_get_version((struct wl_proxy *) river_window_v1), 0);
}

/**
 * @ingroup iface_river_window_v1
 *
 * Inform the window that it is unmaximized. The window might use this
 * information to adapt the style of its client-side window decorations for
 * example.
 *
 * This request modifies window management state and may only be made as
 * part of a manage sequence, see the river_window_manager_v1 description.
 */
static inline void
river_window_v1_inform_unmaximized(struct river_window_v1 *river_window_v1)
{
	wl_proxy_marshal_flags((struct wl_proxy *) river_window_v1,
			 RIVER_WINDOW_V1_INFORM_UNMAXIMIZED, NULL, wl_proxy_get_version((struct wl_proxy *) river_window_v1), 0);
}

/**
 * @ingroup iface_river_window_v1
 *
 * Inform the window that it is fullscreen. The window might use this
 * information to adapt the style of its client-side window decorations for
 * example.
 *
 * This request does not affect the size/position of the window or cause it
 * to become the only window rendered, see the river_window_v1.fullscreen
 * and exit_fullscreen requests for that.
 *
 * This request modifies window management state and may only be made as
 * part of a manage sequence, see the river_window_manager_v1 description.
 */
static inline void
river_window_v1_inform_fullscreen(struct river_window_v1 *river_window_v1)
{
	wl_proxy_marshal_flags((struct wl_proxy *) river_window_v1,
			 RIVER_WINDOW_V1_INFORM_FULLSCREEN, NULL, wl_proxy_get_version((struct wl_proxy *) river_window_v1), 0);
}

/**
 * @ingroup iface_river_window_v1
 *
 * Inform the window that it is not fullscreen. The window might use this
 * information to adapt the style of its client-side window decorations for
 * example.
 *
 * This request does not affect the size/position of the window or cause it
 * to become the only window rendered, see the river_window_v1.fullscreen
 * and exit_fullscreen requests for that.
 *
 * This request modifies window management state and may only be made as
 * part of a manage sequence, see the river_window_manager_v1 description.
 */
static inline void
river_window_v1_inform_not_fullscreen(struct river_window_v1 *river_window_v1)
{
	wl_proxy_marshal_flags((struct wl_proxy *) river_window_v1,
			 RIVER_WINDOW_V1_INFORM_NOT_FULLSCREEN, NULL, wl_proxy_get_version((struct wl_proxy *) river_window_v1), 0);
}

/**
 * @ingroup iface_river_window_v1
 *
 * Make the window fullscreen on the given output. If multiple windows are
 * fullscreen on the same output at the same time only the "top" window in
 * rendering order shall be displayed.
 *
 * All river_shell_surface_v1 objects above the top fullscreen window in
 * the rendering order will continue to be rendered.
 *
 * The compositor will handle the position and dimensions of the window
 * while it is fullscreen. The set_position and propose_dimensions requests
 * shall not affect the current position and dimensions of a fullscreen
 * window.
 *
 * When a fullscreen request is made, the server must send a dimensions
 * event in response as soon as possible. It may not be possible to send a
 * dimensions event in the very next render sequence if, for example, the
 * window takes too long to respond. In this case, the server will send the
 * dimensions event in a future render sequence.
 *
 * The compositor will clip window content, decoration surfaces, and
 * borders to the given output's dimensions while the window is fullscreen.
 * The effects of set_clip_box and set_content_clip_box are ignored while
 * the window is fullscreen.
 *
 * If the output on which a window is currently fullscreen is removed, the
 * windowing state is modified as if there were an exit_fullscreen request
 * made in the same manage sequence as the river_output_v1.removed event.
 *
 * This request does not inform the window that it is fullscreen, see the
 * river_window_v1.inform_fullscreen and inform_not_fullscreen requests.
 *
 * This request modifies window management state and may only be made as
 * part of a manage sequence, see the river_window_manager_v1 description.
 */
static inline void
river_window_v1_fullscreen(struct river_window_v1 *river_window_v1, struct river_output_v1 *output)
{
	wl_proxy_marshal_flags((struct wl_proxy *) river_window_v1,
			 RIVER_WINDOW_V1_FULLSCREEN, NULL, wl_proxy_get_version((struct wl_proxy *) river_window_v1), 0, output);
}

/**
 * @ingroup iface_river_window_v1
 *
 * Make the window not fullscreen.
 *
 * The position and dimensions are undefined after this request is made
 * until a manage sequence in which the window manager makes the
 * propose_dimensions and set_position requests is completed.
 *
 * The window manager should make propose_dimensions and set_position
 * requests in the same manage sequence as the exit_fullscreen request for
 * frame perfection.
 *
 * This request does not inform the window that it is fullscreen, see the
 * river_window_v1.inform_fullscreen and inform_not_fullscreen requests.
 *
 * This request modifies window management state and may only be made as
 * part of a manage sequence, see the river_window_manager_v1 description.
 */
static inline void
river_window_v1_exit_fullscreen(struct river_window_v1 *river_window_v1)
{
	wl_proxy_marshal_flags((struct wl_proxy *) river_window_v1,
			 RIVER_WINDOW_V1_EXIT_FULLSCREEN, NULL, wl_proxy_get_version((struct wl_proxy *) river_window_v1), 0);
}

/**
 * @ingroup iface_river_window_v1
 *
 * Clip the window, including borders and decoration surfaces, to the box
 * specified by the x, y, width, and height arguments. The x/y position of
 * the box is relative to the top left corner of the window.
 *
 * The width and height arguments must be greater than or equal to 0.
 *
 * Setting a clip box with 0 width or height disables clipping.
 *
 * The clip box is ignored while the window is fullscreen.
 *
 * Both set_clip_box and set_content_clip_box may be enabled simultaneously.
 *
 * This request modifies rendering state and may only be made as part of a
 * render sequence, see the river_window_manager_v1 description.
 */
static inline void
river_window_v1_set_clip_box(struct river_window_v1 *river_window_v1, int32_t x, int32_t y, int32_t width, int32_t height)
{
	wl_proxy_marshal_flags((struct wl_proxy *) river_window_v1,
			 RIVER_WINDOW_V1_SET_CLIP_BOX, NULL, wl_proxy_get_version((struct wl_proxy *) river_window_v1), 0, x, y, width, height);
}

/**
 * @ingroup iface_river_window_v1
 *
 * Clip the content of the window, excluding borders and decoration
 * surfaces, to the box specified by the x, y, width, and height arguments.
 * The x/y position of the box is relative to the top left corner of the
 * window.
 *
 * Borders drawn by the compositor (see set_borders) are placed around the
 * intersection of the window content (as defined by the dimensions event)
 * and the content clip box when content clipping is enabled.
 *
 * The width and height arguments must be greater than or equal to 0.
 *
 * Setting a box with 0 width or height disables content clipping.
 *
 * The content clip box is ignored while the window is fullscreen.
 *
 * Both set_clip_box and set_content_clip_box may be enabled simultaneously.
 *
 * This request modifies rendering state and may only be made as part of a
 * render sequence, see the river_window_manager_v1 description.
 */
static inline void
river_window_v1_set_content_clip_box(struct river_window_v1 *river_window_v1, int32_t x, int32_t y, int32_t width, int32_t height)
{
	wl_proxy_marshal_flags((struct wl_proxy *) river_window_v1,
			 RIVER_WINDOW_V1_SET_CONTENT_CLIP_BOX, NULL, wl_proxy_get_version((struct wl_proxy *) river_window_v1), 0, x, y, width, height);
}

#ifndef RIVER_DECORATION_V1_ERROR_ENUM
#define RIVER_DECORATION_V1_ERROR_ENUM
enum river_decoration_v1_error {
	/**
	 * failed to commit the surface before the window manager commit
	 */
	RIVER_DECORATION_V1_ERROR_NO_COMMIT = 0,
};
#endif /* RIVER_DECORATION_V1_ERROR_ENUM */

#define RIVER_DECORATION_V1_DESTROY 0
#define RIVER_DECORATION_V1_SET_OFFSET 1
#define RIVER_DECORATION_V1_SYNC_NEXT_COMMIT 2


/**
 * @ingroup iface_river_decoration_v1
 */
#define RIVER_DECORATION_V1_DESTROY_SINCE_VERSION 1
/**
 * @ingroup iface_river_decoration_v1
 */
#define RIVER_DECORATION_V1_SET_OFFSET_SINCE_VERSION 1
/**
 * @ingroup iface_river_decoration_v1
 */
#define RIVER_DECORATION_V1_SYNC_NEXT_COMMIT_SINCE_VERSION 1

/** @ingroup iface_river_decoration_v1 */
static inline void
river_decoration_v1_set_user_data(struct river_decoration_v1 *river_decoration_v1, void *user_data)
{
	wl_proxy_set_user_data((struct wl_proxy *) river_decoration_v1, user_data);
}

/** @ingroup iface_river_decoration_v1 */
static inline void *
river_decoration_v1_get_user_data(struct river_decoration_v1 *river_decoration_v1)
{
	return wl_proxy_get_user_data((struct wl_proxy *) river_decoration_v1);
}

static inline uint32_t
river_decoration_v1_get_version(struct river_decoration_v1 *river_decoration_v1)
{
	return wl_proxy_get_version((struct wl_proxy *) river_decoration_v1);
}

/**
 * @ingroup iface_river_decoration_v1
 *
 * This request indicates that the client will no longer use the decoration
 * object and that it may be safely destroyed.
 */
static inline void
river_decoration_v1_destroy(struct river_decoration_v1 *river_decoration_v1)
{
	wl_proxy_marshal_flags((struct wl_proxy *) river_decoration_v1,
			 RIVER_DECORATION_V1_DESTROY, NULL, wl_proxy_get_version((struct wl_proxy *) river_decoration_v1), WL_MARSHAL_FLAG_DESTROY);
}

/**
 * @ingroup iface_river_decoration_v1
 *
 * This request sets the offset of the decoration surface from the top left
 * corner of the window.
 *
 * If this request is never sent, the x and y offsets are undefined by this
 * protocol and left up to the compositor.
 *
 * This request modifies rendering state and may only be made as part of a
 * render sequence, see the river_window_manager_v1 description.
 */
static inline void
river_decoration_v1_set_offset(struct river_decoration_v1 *river_decoration_v1, int32_t x, int32_t y)
{
	wl_proxy_marshal_flags((struct wl_proxy *) river_decoration_v1,
			 RIVER_DECORATION_V1_SET_OFFSET, NULL, wl_proxy_get_version((struct wl_proxy *) river_decoration_v1), 0, x, y);
}

/**
 * @ingroup iface_river_decoration_v1
 *
 * Synchronize application of the next wl_surface.commit request on the
 * decoration surface with rest of the state atomically applied with the
 * next river_window_manager_v1.render_finish request.
 *
 * The client must make a wl_surface.commit request on the decoration
 * surface after this request and before the render_finish request, failure
 * to do so is a protocol error.
 *
 * This request modifies rendering state and may only be made as part of a
 * render sequence, see the river_window_manager_v1 description.
 */
static inline void
river_decoration_v1_sync_next_commit(struct river_decoration_v1 *river_decoration_v1)
{
	wl_proxy_marshal_flags((struct wl_proxy *) river_decoration_v1,
			 RIVER_DECORATION_V1_SYNC_NEXT_COMMIT, NULL, wl_proxy_get_version((struct wl_proxy *) river_decoration_v1), 0);
}

#ifndef RIVER_SHELL_SURFACE_V1_ERROR_ENUM
#define RIVER_SHELL_SURFACE_V1_ERROR_ENUM
enum river_shell_surface_v1_error {
	/**
	 * shell surface already has a node object
	 */
	RIVER_SHELL_SURFACE_V1_ERROR_NODE_EXISTS = 0,
	/**
	 * failed to commit the surface before the window manager commit
	 */
	RIVER_SHELL_SURFACE_V1_ERROR_NO_COMMIT = 1,
};
#endif /* RIVER_SHELL_SURFACE_V1_ERROR_ENUM */

#define RIVER_SHELL_SURFACE_V1_DESTROY 0
#define RIVER_SHELL_SURFACE_V1_GET_NODE 1
#define RIVER_SHELL_SURFACE_V1_SYNC_NEXT_COMMIT 2


/**
 * @ingroup iface_river_shell_surface_v1
 */
#define RIVER_SHELL_SURFACE_V1_DESTROY_SINCE_VERSION 1
/**
 * @ingroup iface_river_shell_surface_v1
 */
#define RIVER_SHELL_SURFACE_V1_GET_NODE_SINCE_VERSION 1
/**
 * @ingroup iface_river_shell_surface_v1
 */
#define RIVER_SHELL_SURFACE_V1_SYNC_NEXT_COMMIT_SINCE_VERSION 1

/** @ingroup iface_river_shell_surface_v1 */
static inline void
river_shell_surface_v1_set_user_data(struct river_shell_surface_v1 *river_shell_surface_v1, void *user_data)
{
	wl_proxy_set_user_data((struct wl_proxy *) river_shell_surface_v1, user_data);
}

/** @ingroup iface_river_shell_surface_v1 */
static inline void *
river_shell_surface_v1_get_user_data(struct river_shell_surface_v1 *river_shell_surface_v1)
{
	return wl_proxy_get_user_data((struct wl_proxy *) river_shell_surface_v1);
}

static inline uint32_t
river_shell_surface_v1_get_version(struct river_shell_surface_v1 *river_shell_surface_v1)
{
	return wl_proxy_get_version((struct wl_proxy *) river_shell_surface_v1);
}

/**
 * @ingroup iface_river_shell_surface_v1
 *
 * This request indicates that the client will no longer use the shell
 * surface object and that it may be safely destroyed.
 */
static inline void
river_shell_surface_v1_destroy(struct river_shell_surface_v1 *river_shell_surface_v1)
{
	wl_proxy_marshal_flags((struct wl_proxy *) river_shell_surface_v1,
			 RIVER_SHELL_SURFACE_V1_DESTROY, NULL, wl_proxy_get_version((struct wl_proxy *) river_shell_surface_v1), WL_MARSHAL_FLAG_DESTROY);
}

/**
 * @ingroup iface_river_shell_surface_v1
 *
 * Get the node in the render list corresponding to the shell surface.
 *
 * It is a protocol error to make this request more than once for a single
 * shell surface.
 */
static inline struct river_node_v1 *
river_shell_surface_v1_get_node(struct river_shell_surface_v1 *river_shell_surface_v1)
{
	struct wl_proxy *id;

	id = wl_proxy_marshal_flags((struct wl_proxy *) river_shell_surface_v1,
			 RIVER_SHELL_SURFACE_V1_GET_NODE, &river_node_v1_interface, wl_proxy_get_version((struct wl_proxy *) river_shell_surface_v1), 0, NULL);

	return (struct river_node_v1 *) id;
}

/**
 * @ingroup iface_river_shell_surface_v1
 *
 * Synchronize application of the next wl_surface.commit request on the
 * shell surface with rest of the rendering state atomically applied with
 * the next river_window_manager_v1.render_finish request.
 *
 * The client must make a wl_surface.commit request on the shell surface
 * after this request and before the render_finish request, failure to do
 * so is a protocol error.
 *
 * This request modifies rendering state and may only be made as part of a
 * render sequence, see the river_window_manager_v1 description.
 */
static inline void
river_shell_surface_v1_sync_next_commit(struct river_shell_surface_v1 *river_shell_surface_v1)
{
	wl_proxy_marshal_flags((struct wl_proxy *) river_shell_surface_v1,
			 RIVER_SHELL_SURFACE_V1_SYNC_NEXT_COMMIT, NULL, wl_proxy_get_version((struct wl_proxy *) river_shell_surface_v1), 0);
}

#define RIVER_NODE_V1_DESTROY 0
#define RIVER_NODE_V1_SET_POSITION 1
#define RIVER_NODE_V1_PLACE_TOP 2
#define RIVER_NODE_V1_PLACE_BOTTOM 3
#define RIVER_NODE_V1_PLACE_ABOVE 4
#define RIVER_NODE_V1_PLACE_BELOW 5


/**
 * @ingroup iface_river_node_v1
 */
#define RIVER_NODE_V1_DESTROY_SINCE_VERSION 1
/**
 * @ingroup iface_river_node_v1
 */
#define RIVER_NODE_V1_SET_POSITION_SINCE_VERSION 1
/**
 * @ingroup iface_river_node_v1
 */
#define RIVER_NODE_V1_PLACE_TOP_SINCE_VERSION 1
/**
 * @ingroup iface_river_node_v1
 */
#define RIVER_NODE_V1_PLACE_BOTTOM_SINCE_VERSION 1
/**
 * @ingroup iface_river_node_v1
 */
#define RIVER_NODE_V1_PLACE_ABOVE_SINCE_VERSION 1
/**
 * @ingroup iface_river_node_v1
 */
#define RIVER_NODE_V1_PLACE_BELOW_SINCE_VERSION 1

/** @ingroup iface_river_node_v1 */
static inline void
river_node_v1_set_user_data(struct river_node_v1 *river_node_v1, void *user_data)
{
	wl_proxy_set_user_data((struct wl_proxy *) river_node_v1, user_data);
}

/** @ingroup iface_river_node_v1 */
static inline void *
river_node_v1_get_user_data(struct river_node_v1 *river_node_v1)
{
	return wl_proxy_get_user_data((struct wl_proxy *) river_node_v1);
}

static inline uint32_t
river_node_v1_get_version(struct river_node_v1 *river_node_v1)
{
	return wl_proxy_get_version((struct wl_proxy *) river_node_v1);
}

/**
 * @ingroup iface_river_node_v1
 *
 * This request indicates that the client will no longer use the node
 * object and that it may be safely destroyed.
 */
static inline void
river_node_v1_destroy(struct river_node_v1 *river_node_v1)
{
	wl_proxy_marshal_flags((struct wl_proxy *) river_node_v1,
			 RIVER_NODE_V1_DESTROY, NULL, wl_proxy_get_version((struct wl_proxy *) river_node_v1), WL_MARSHAL_FLAG_DESTROY);
}

/**
 * @ingroup iface_river_node_v1
 *
 * Set the absolute position of the node in the compositor's logical
 * coordinate space. The x and y coordinates may be positive or negative.
 *
 * Note that the position of a river_window_v1 refers to the position of
 * the window content and is unaffected by the presence of borders or
 * decoration surfaces.
 *
 * If this request is never sent, the position of the node is undefined by
 * this protocol and left up to the compositor.
 *
 * This request modifies rendering state and may only be made as part of a
 * render sequence, see the river_window_manager_v1 description.
 */
static inline void
river_node_v1_set_position(struct river_node_v1 *river_node_v1, int32_t x, int32_t y)
{
	wl_proxy_marshal_flags((struct wl_proxy *) river_node_v1,
			 RIVER_NODE_V1_SET_POSITION, NULL, wl_proxy_get_version((struct wl_proxy *) river_node_v1), 0, x, y);
}

/**
 * @ingroup iface_river_node_v1
 *
 * This request places the node above all other nodes in the compositor's
 * render list.
 *
 * This request modifies rendering state and may only be made as part of a
 * render sequence, see the river_window_manager_v1 description.
 */
static inline void
river_node_v1_place_top(struct river_node_v1 *river_node_v1)
{
	wl_proxy_marshal_flags((struct wl_proxy *) river_node_v1,
			 RIVER_NODE_V1_PLACE_TOP, NULL, wl_proxy_get_version((struct wl_proxy *) river_node_v1), 0);
}

/**
 * @ingroup iface_river_node_v1
 *
 * This request places the node below all other nodes in the compositor's
 * render list.
 *
 * This request modifies rendering state and may only be made as part of a
 * render sequence, see the river_window_manager_v1 description.
 */
static inline void
river_node_v1_place_bottom(struct river_node_v1 *river_node_v1)
{
	wl_proxy_marshal_flags((struct wl_proxy *) river_node_v1,
			 RIVER_NODE_V1_PLACE_BOTTOM, NULL, wl_proxy_get_version((struct wl_proxy *) river_node_v1), 0);
}

/**
 * @ingroup iface_river_node_v1
 *
 * This request places the node directly above another node in the
 * compositor's render list.
 *
 * Attempting to place a node above itself has no effect.
 *
 * This request modifies rendering state and may only be made as part of a
 * render sequence, see the river_window_manager_v1 description.
 */
static inline void
river_node_v1_place_above(struct river_node_v1 *river_node_v1, struct river_node_v1 *other)
{
	wl_proxy_marshal_flags((struct wl_proxy *) river_node_v1,
			 RIVER_NODE_V1_PLACE_ABOVE, NULL, wl_proxy_get_version((struct wl_proxy *) river_node_v1), 0, other);
}

/**
 * @ingroup iface_river_node_v1
 *
 * This request places the node directly below another node in the
 * compositor's render list.
 *
 * Attempting to place a node below itself has no effect.
 *
 * This request modifies rendering state and may only be made as part of a
 * render sequence, see the river_window_manager_v1 description.
 */
static inline void
river_node_v1_place_below(struct river_node_v1 *river_node_v1, struct river_node_v1 *other)
{
	wl_proxy_marshal_flags((struct wl_proxy *) river_node_v1,
			 RIVER_NODE_V1_PLACE_BELOW, NULL, wl_proxy_get_version((struct wl_proxy *) river_node_v1), 0, other);
}

/**
 * @ingroup iface_river_output_v1
 * @struct river_output_v1_listener
 */
struct river_output_v1_listener {
	/**
	 * the output is removed
	 *
	 * This event indicates that the logical output is no longer
	 * conceptually part of window management space.
	 *
	 * The server will send no further events on this object and ignore
	 * any request (other than river_output_v1.destroy) made after this
	 * event is sent. The client should destroy this object with the
	 * river_output_v1.destroy request to free up resources.
	 *
	 * This event may be sent because a corresponding physical output
	 * has been physically unplugged or because some output
	 * configuration has changed.
	 *
	 * This event will be followed by a manage_start event after all
	 * other new state has been sent by the server.
	 */
	void (*removed)(void *data,
			struct river_output_v1 *river_output_v1);
	/**
	 * corresponding wl_output
	 *
	 * The wl_output object corresponding to the river_output_v1. The
	 * argument is the global name of the wl_output advertised with
	 * wl_registry.global.
	 *
	 * It is guaranteed that the corresponding wl_output is advertised
	 * before this event is sent.
	 *
	 * This event is sent exactly once. The wl_output associated with a
	 * river_output_v1 cannot change. It is guaranteed that there is a
	 * 1-to-1 mapping between wl_output and river_output_v1 objects.
	 *
	 * The global_remove event for the corresponding wl_output may be
	 * sent before the river_output_v1.remove event. This is due to the
	 * fact that river_output_v1 state changes are synced to the river
	 * window management manage sequence while changes to globals are
	 * not.
	 *
	 * Rationale: The window manager may need information provided by
	 * the wl_output interface such as the name/description. It also
	 * may need the wl_output object to start screencopy for example.
	 * @param name name of the wl_output global
	 */
	void (*wl_output)(void *data,
			  struct river_output_v1 *river_output_v1,
			  uint32_t name);
	/**
	 * output position
	 *
	 * This event indicates the position of the output in the
	 * compositor's logical coordinate space. The x and y coordinates
	 * may be positive or negative.
	 *
	 * This event is sent once when the river_output_v1 is created and
	 * again whenever the position changes.
	 *
	 * This event will be followed by a manage_start event after all
	 * other new state has been sent by the server.
	 *
	 * The server must guarantee that the position and dimensions
	 * events do not cause the areas of multiple logical outputs to
	 * overlap when the corresponding manage_start event is received.
	 * @param x global x coordinate
	 * @param y global y coordinate
	 */
	void (*position)(void *data,
			 struct river_output_v1 *river_output_v1,
			 int32_t x,
			 int32_t y);
	/**
	 * output dimensions
	 *
	 * This event indicates the dimensions of the output in the
	 * compositor's logical coordinate space. The width and height will
	 * always be strictly greater than zero.
	 *
	 * This event is sent once when the river_output_v1 is created and
	 * again whenever the dimensions change.
	 *
	 * This event will be followed by a manage_start event after all
	 * other new state has been sent by the server.
	 *
	 * The server must guarantee that the position and dimensions
	 * events do not cause the areas of multiple logical outputs to
	 * overlap when the corresponding manage_start event is received.
	 * @param width output width
	 * @param height output height
	 */
	void (*dimensions)(void *data,
			   struct river_output_v1 *river_output_v1,
			   int32_t width,
			   int32_t height);
};

/**
 * @ingroup iface_river_output_v1
 */
static inline int
river_output_v1_add_listener(struct river_output_v1 *river_output_v1,
			     const struct river_output_v1_listener *listener, void *data)
{
	return wl_proxy_add_listener((struct wl_proxy *) river_output_v1,
				     (void (**)(void)) listener, data);
}

#define RIVER_OUTPUT_V1_DESTROY 0

/**
 * @ingroup iface_river_output_v1
 */
#define RIVER_OUTPUT_V1_REMOVED_SINCE_VERSION 1
/**
 * @ingroup iface_river_output_v1
 */
#define RIVER_OUTPUT_V1_WL_OUTPUT_SINCE_VERSION 1
/**
 * @ingroup iface_river_output_v1
 */
#define RIVER_OUTPUT_V1_POSITION_SINCE_VERSION 1
/**
 * @ingroup iface_river_output_v1
 */
#define RIVER_OUTPUT_V1_DIMENSIONS_SINCE_VERSION 1

/**
 * @ingroup iface_river_output_v1
 */
#define RIVER_OUTPUT_V1_DESTROY_SINCE_VERSION 1

/** @ingroup iface_river_output_v1 */
static inline void
river_output_v1_set_user_data(struct river_output_v1 *river_output_v1, void *user_data)
{
	wl_proxy_set_user_data((struct wl_proxy *) river_output_v1, user_data);
}

/** @ingroup iface_river_output_v1 */
static inline void *
river_output_v1_get_user_data(struct river_output_v1 *river_output_v1)
{
	return wl_proxy_get_user_data((struct wl_proxy *) river_output_v1);
}

static inline uint32_t
river_output_v1_get_version(struct river_output_v1 *river_output_v1)
{
	return wl_proxy_get_version((struct wl_proxy *) river_output_v1);
}

/**
 * @ingroup iface_river_output_v1
 *
 * This request indicates that the client will no longer use the output
 * object and that it may be safely destroyed.
 *
 * This request should be made after the river_output_v1.removed event is
 * received to complete destruction of the output.
 */
static inline void
river_output_v1_destroy(struct river_output_v1 *river_output_v1)
{
	wl_proxy_marshal_flags((struct wl_proxy *) river_output_v1,
			 RIVER_OUTPUT_V1_DESTROY, NULL, wl_proxy_get_version((struct wl_proxy *) river_output_v1), WL_MARSHAL_FLAG_DESTROY);
}

#ifndef RIVER_SEAT_V1_MODIFIERS_ENUM
#define RIVER_SEAT_V1_MODIFIERS_ENUM
/**
 * @ingroup iface_river_seat_v1
 * a set of keyboard modifiers
 *
 * This enum is used to describe the keyboard modifiers that must be held
 * down to trigger a key binding or pointer binding.
 *
 * Note that river and wlroots use the values 2 and 16 for capslock and
 * numlock internally. It doesn't make sense to use locked modifiers for
 * bindings however so these values are not included in this enum.
 */
enum river_seat_v1_modifiers {
	RIVER_SEAT_V1_MODIFIERS_NONE = 0,
	RIVER_SEAT_V1_MODIFIERS_SHIFT = 1,
	RIVER_SEAT_V1_MODIFIERS_CTRL = 4,
	/**
	 * commonly called alt
	 */
	RIVER_SEAT_V1_MODIFIERS_MOD1 = 8,
	RIVER_SEAT_V1_MODIFIERS_MOD3 = 32,
	/**
	 * commonly called super or logo
	 */
	RIVER_SEAT_V1_MODIFIERS_MOD4 = 64,
	RIVER_SEAT_V1_MODIFIERS_MOD5 = 128,
};
#endif /* RIVER_SEAT_V1_MODIFIERS_ENUM */

/**
 * @ingroup iface_river_seat_v1
 * @struct river_seat_v1_listener
 */
struct river_seat_v1_listener {
	/**
	 * the seat is removed
	 *
	 * This event indicates that seat is no longer in use and should
	 * be destroyed.
	 *
	 * The server will send no further events on this object and ignore
	 * any request (other than river_seat_v1.destroy) made after this
	 * event is sent. The client should destroy this object with the
	 * river_seat_v1.destroy request to free up resources.
	 *
	 * This event will be followed by a manage_start event after all
	 * other new state has been sent by the server.
	 */
	void (*removed)(void *data,
			struct river_seat_v1 *river_seat_v1);
	/**
	 * corresponding wl_seat
	 *
	 * The wl_seat object corresponding to the river_seat_v1. The
	 * argument is the global name of the wl_seat advertised with
	 * wl_registry.global.
	 *
	 * It is guaranteed that the corresponding wl_seat is advertised
	 * before this event is sent.
	 *
	 * This event is sent exactly once. The wl_seat associated with a
	 * river_seat_v1 cannot change. It is guaranteed that there is a
	 * 1-to-1 mapping between wl_seat and river_seat_v1 objects.
	 *
	 * The global_remove event for the corresponding wl_seat may be
	 * sent before the river_seat_v1.remove event. This is due to the
	 * fact that river_seat_v1 state changes are synced to the river
	 * window management manage sequence while changes to globals are
	 * not.
	 *
	 * Rationale: The window manager may want to trigger window
	 * management state changes based on normal input events received
	 * by its shell surfaces for example.
	 * @param name name of the wl_seat global
	 */
	void (*wl_seat)(void *data,
			struct river_seat_v1 *river_seat_v1,
			uint32_t name);
	/**
	 * pointer entered a window
	 *
	 * The seat's pointer entered the given window's area.
	 *
	 * The area of a window is defined to include the area defined by
	 * the window dimensions, borders configured using
	 * river_window_v1.set_borders, and the input regions of decoration
	 * surfaces. In particular, it does not include input regions of
	 * surfaces belonging to the window that extend outside the window
	 * dimensions.
	 *
	 * The pointer of a seat may only enter a single window at a time.
	 * When the pointer moves between windows, the pointer_leave event
	 * for the old window must be sent before the pointer_enter event
	 * for the new window.
	 *
	 * This event will be followed by a manage_start event after all
	 * other new state has been sent by the server.
	 * @param window window entered
	 */
	void (*pointer_enter)(void *data,
			      struct river_seat_v1 *river_seat_v1,
			      struct river_window_v1 *window);
	/**
	 * pointer left the entered window
	 *
	 * The seat's pointer left the window for which pointer_enter was
	 * most recently sent. See pointer_enter for details.
	 *
	 * This event will be followed by a manage_start event after all
	 * other new state has been sent by the server.
	 */
	void (*pointer_leave)(void *data,
			      struct river_seat_v1 *river_seat_v1);
	/**
	 * a window has been interacted with
	 *
	 * A window has been interacted with beyond the pointer merely
	 * passing over it. This event might be sent due to a pointer
	 * button press or due to a touch/tablet tool interaction with the
	 * window.
	 *
	 * There are no guarantees regarding how this event is sent in
	 * relation to the pointer_enter and pointer_leave events as the
	 * interaction may use touch or tablet tool input.
	 *
	 * Rationale: this event gives window managers necessary
	 * information to determine when to send keyboard focus, raise a
	 * window that already has keyboard focus, etc. Rather than expose
	 * all pointer, touch, and tablet events to window managers, a
	 * policy over mechanism approach is taken.
	 *
	 * This event will be followed by a manage_start event after all
	 * other new state has been sent by the server.
	 * @param window window interacted with
	 */
	void (*window_interaction)(void *data,
				   struct river_seat_v1 *river_seat_v1,
				   struct river_window_v1 *window);
	/**
	 * a shell surface has been interacted with
	 *
	 * A shell surface has been interacted with beyond the pointer
	 * merely passing over it. This event might be sent due to a
	 * pointer button press or due to a touch/tablet tool interaction
	 * with the shell_surface.
	 *
	 * There are no guarantees regarding how this event is sent in
	 * relation to the pointer_enter and pointer_leave events as the
	 * interaction may use touch or tablet tool input.
	 *
	 * Rationale: While the shell surface does receive all wl_pointer,
	 * wl_touch, etc. input events for the surface directly, these
	 * events do not necessarily trigger a manage sequence and
	 * therefore do not allow the window manager to update focus or
	 * perform other actions in response to the input in a race-free
	 * way.
	 *
	 * This event will be followed by a manage_start event after all
	 * other new state has been sent by the server.
	 * @param shell_surface shell surface interacted with
	 */
	void (*shell_surface_interaction)(void *data,
					  struct river_seat_v1 *river_seat_v1,
					  struct river_shell_surface_v1 *shell_surface);
	/**
	 * total cumulative motion since op start
	 *
	 * This event indicates the total change in position since the
	 * start of the operation of the pointer/touch point/etc.
	 *
	 * This event will be followed by a manage_start event after all
	 * other new state has been sent by the server.
	 * @param dx total change in x
	 * @param dy total change in y
	 */
	void (*op_delta)(void *data,
			 struct river_seat_v1 *river_seat_v1,
			 int32_t dx,
			 int32_t dy);
	/**
	 * operation input has been released
	 *
	 * The input driving the current interactive operation has been
	 * released. For a pointer op for example, all pointer buttons have
	 * been released.
	 *
	 * Depending on the op type, op_delta events may continue to be
	 * sent until the op is ended with the op_end request.
	 *
	 * This event is sent at most once during an interactive operation.
	 *
	 * This event will be followed by a manage_start event after all
	 * other new state has been sent by the server.
	 */
	void (*op_release)(void *data,
			   struct river_seat_v1 *river_seat_v1);
	/**
	 * The current position of the pointer
	 *
	 * The current position of the pointer in the compositor's
	 * logical coordinate space.
	 *
	 * This state is special in that a change in pointer position alone
	 * must not cause the compositor to start a manage sequence.
	 *
	 * Assuming the seat has a pointer, this event must be sent in
	 * every manage sequence unless there is no change in x/y position
	 * since the last time this event was sent.
	 * @param x global x coordinate
	 * @param y global y coordinate
	 * @since 2
	 */
	void (*pointer_position)(void *data,
				 struct river_seat_v1 *river_seat_v1,
				 int32_t x,
				 int32_t y);
};

/**
 * @ingroup iface_river_seat_v1
 */
static inline int
river_seat_v1_add_listener(struct river_seat_v1 *river_seat_v1,
			   const struct river_seat_v1_listener *listener, void *data)
{
	return wl_proxy_add_listener((struct wl_proxy *) river_seat_v1,
				     (void (**)(void)) listener, data);
}

#define RIVER_SEAT_V1_DESTROY 0
#define RIVER_SEAT_V1_FOCUS_WINDOW 1
#define RIVER_SEAT_V1_FOCUS_SHELL_SURFACE 2
#define RIVER_SEAT_V1_CLEAR_FOCUS 3
#define RIVER_SEAT_V1_OP_START_POINTER 4
#define RIVER_SEAT_V1_OP_END 5
#define RIVER_SEAT_V1_GET_POINTER_BINDING 6
#define RIVER_SEAT_V1_SET_XCURSOR_THEME 7
#define RIVER_SEAT_V1_POINTER_WARP 8

/**
 * @ingroup iface_river_seat_v1
 */
#define RIVER_SEAT_V1_REMOVED_SINCE_VERSION 1
/**
 * @ingroup iface_river_seat_v1
 */
#define RIVER_SEAT_V1_WL_SEAT_SINCE_VERSION 1
/**
 * @ingroup iface_river_seat_v1
 */
#define RIVER_SEAT_V1_POINTER_ENTER_SINCE_VERSION 1
/**
 * @ingroup iface_river_seat_v1
 */
#define RIVER_SEAT_V1_POINTER_LEAVE_SINCE_VERSION 1
/**
 * @ingroup iface_river_seat_v1
 */
#define RIVER_SEAT_V1_WINDOW_INTERACTION_SINCE_VERSION 1
/**
 * @ingroup iface_river_seat_v1
 */
#define RIVER_SEAT_V1_SHELL_SURFACE_INTERACTION_SINCE_VERSION 1
/**
 * @ingroup iface_river_seat_v1
 */
#define RIVER_SEAT_V1_OP_DELTA_SINCE_VERSION 1
/**
 * @ingroup iface_river_seat_v1
 */
#define RIVER_SEAT_V1_OP_RELEASE_SINCE_VERSION 1
/**
 * @ingroup iface_river_seat_v1
 */
#define RIVER_SEAT_V1_POINTER_POSITION_SINCE_VERSION 2

/**
 * @ingroup iface_river_seat_v1
 */
#define RIVER_SEAT_V1_DESTROY_SINCE_VERSION 1
/**
 * @ingroup iface_river_seat_v1
 */
#define RIVER_SEAT_V1_FOCUS_WINDOW_SINCE_VERSION 1
/**
 * @ingroup iface_river_seat_v1
 */
#define RIVER_SEAT_V1_FOCUS_SHELL_SURFACE_SINCE_VERSION 1
/**
 * @ingroup iface_river_seat_v1
 */
#define RIVER_SEAT_V1_CLEAR_FOCUS_SINCE_VERSION 1
/**
 * @ingroup iface_river_seat_v1
 */
#define RIVER_SEAT_V1_OP_START_POINTER_SINCE_VERSION 1
/**
 * @ingroup iface_river_seat_v1
 */
#define RIVER_SEAT_V1_OP_END_SINCE_VERSION 1
/**
 * @ingroup iface_river_seat_v1
 */
#define RIVER_SEAT_V1_GET_POINTER_BINDING_SINCE_VERSION 1
/**
 * @ingroup iface_river_seat_v1
 */
#define RIVER_SEAT_V1_SET_XCURSOR_THEME_SINCE_VERSION 2
/**
 * @ingroup iface_river_seat_v1
 */
#define RIVER_SEAT_V1_POINTER_WARP_SINCE_VERSION 3

/** @ingroup iface_river_seat_v1 */
static inline void
river_seat_v1_set_user_data(struct river_seat_v1 *river_seat_v1, void *user_data)
{
	wl_proxy_set_user_data((struct wl_proxy *) river_seat_v1, user_data);
}

/** @ingroup iface_river_seat_v1 */
static inline void *
river_seat_v1_get_user_data(struct river_seat_v1 *river_seat_v1)
{
	return wl_proxy_get_user_data((struct wl_proxy *) river_seat_v1);
}

static inline uint32_t
river_seat_v1_get_version(struct river_seat_v1 *river_seat_v1)
{
	return wl_proxy_get_version((struct wl_proxy *) river_seat_v1);
}

/**
 * @ingroup iface_river_seat_v1
 *
 * This request indicates that the client will no longer use the seat
 * object and that it may be safely destroyed.
 *
 * This request should be made after the river_seat_v1.removed event is
 * received to complete destruction of the seat.
 */
static inline void
river_seat_v1_destroy(struct river_seat_v1 *river_seat_v1)
{
	wl_proxy_marshal_flags((struct wl_proxy *) river_seat_v1,
			 RIVER_SEAT_V1_DESTROY, NULL, wl_proxy_get_version((struct wl_proxy *) river_seat_v1), WL_MARSHAL_FLAG_DESTROY);
}

/**
 * @ingroup iface_river_seat_v1
 *
 * Request that the compositor send keyboard input to the given window.
 *
 * This request modifies window management state and may only be made as
 * part of a manage sequence, see the river_window_manager_v1 description.
 */
static inline void
river_seat_v1_focus_window(struct river_seat_v1 *river_seat_v1, struct river_window_v1 *window)
{
	wl_proxy_marshal_flags((struct wl_proxy *) river_seat_v1,
			 RIVER_SEAT_V1_FOCUS_WINDOW, NULL, wl_proxy_get_version((struct wl_proxy *) river_seat_v1), 0, window);
}

/**
 * @ingroup iface_river_seat_v1
 *
 * Request that the compositor send keyboard input to the given shell
 * surface.
 *
 * This request modifies window management state and may only be made as
 * part of a manage sequence, see the river_window_manager_v1 description.
 */
static inline void
river_seat_v1_focus_shell_surface(struct river_seat_v1 *river_seat_v1, struct river_shell_surface_v1 *shell_surface)
{
	wl_proxy_marshal_flags((struct wl_proxy *) river_seat_v1,
			 RIVER_SEAT_V1_FOCUS_SHELL_SURFACE, NULL, wl_proxy_get_version((struct wl_proxy *) river_seat_v1), 0, shell_surface);
}

/**
 * @ingroup iface_river_seat_v1
 *
 * Request that the compositor not send keyboard input to any client.
 *
 * This request modifies window management state and may only be made as
 * part of a manage sequence, see the river_window_manager_v1 description.
 */
static inline void
river_seat_v1_clear_focus(struct river_seat_v1 *river_seat_v1)
{
	wl_proxy_marshal_flags((struct wl_proxy *) river_seat_v1,
			 RIVER_SEAT_V1_CLEAR_FOCUS, NULL, wl_proxy_get_version((struct wl_proxy *) river_seat_v1), 0);
}

/**
 * @ingroup iface_river_seat_v1
 *
 * Start an interactive pointer operation. During the operation, op_delta
 * events will be sent based on pointer input.
 *
 * When all pointer buttons are released, the op_release event is sent.
 *
 * The pointer operation continues until the op_end request is made during
 * a manage sequence and that manage sequence is finished.
 *
 * The window manager may use this operation to implement interactive
 * move/resize of windows by setting the position of windows and proposing
 * dimensions based off of the op_delta events.
 *
 * This request is ignored if an operation is already in progress.
 *
 * This request modifies window management state and may only be made as
 * part of a manage sequence, see the river_window_manager_v1 description.
 */
static inline void
river_seat_v1_op_start_pointer(struct river_seat_v1 *river_seat_v1)
{
	wl_proxy_marshal_flags((struct wl_proxy *) river_seat_v1,
			 RIVER_SEAT_V1_OP_START_POINTER, NULL, wl_proxy_get_version((struct wl_proxy *) river_seat_v1), 0);
}

/**
 * @ingroup iface_river_seat_v1
 *
 * End an interactive operation.
 *
 * This request is ignored if there is no operation in progress.
 *
 * This request modifies window management state and may only be made as
 * part of a manage sequence, see the river_window_manager_v1 description.
 */
static inline void
river_seat_v1_op_end(struct river_seat_v1 *river_seat_v1)
{
	wl_proxy_marshal_flags((struct wl_proxy *) river_seat_v1,
			 RIVER_SEAT_V1_OP_END, NULL, wl_proxy_get_version((struct wl_proxy *) river_seat_v1), 0);
}

/**
 * @ingroup iface_river_seat_v1
 *
 * Define a pointer binding in terms of a pointer button, keyboard
 * modifiers, and other configurable properties.
 *
 * The button argument is a Linux input event code defined in the
 * linux/input-event-codes.h header file (e.g. BTN_RIGHT).
 *
 * The new pointer binding is not enabled until initial configuration is
 * completed and the enable request is made during a manage sequence.
 */
static inline struct river_pointer_binding_v1 *
river_seat_v1_get_pointer_binding(struct river_seat_v1 *river_seat_v1, uint32_t button, uint32_t modifiers)
{
	struct wl_proxy *id;

	id = wl_proxy_marshal_flags((struct wl_proxy *) river_seat_v1,
			 RIVER_SEAT_V1_GET_POINTER_BINDING, &river_pointer_binding_v1_interface, wl_proxy_get_version((struct wl_proxy *) river_seat_v1), 0, NULL, button, modifiers);

	return (struct river_pointer_binding_v1 *) id;
}

/**
 * @ingroup iface_river_seat_v1
 *
 * Set the XCursor theme for the seat. This theme is used for cursors
 * rendered by the compositor, but not necessarily for cursors rendered by
 * clients.
 *
 * Note: The window manager may also wish to set the XCURSOR_THEME and
 * XCURSOR_SIZE environment variable for programs it starts.
 */
static inline void
river_seat_v1_set_xcursor_theme(struct river_seat_v1 *river_seat_v1, const char *name, uint32_t size)
{
	wl_proxy_marshal_flags((struct wl_proxy *) river_seat_v1,
			 RIVER_SEAT_V1_SET_XCURSOR_THEME, NULL, wl_proxy_get_version((struct wl_proxy *) river_seat_v1), 0, name, size);
}

/**
 * @ingroup iface_river_seat_v1
 *
 * Warp the pointer to the given position in the compositor's logical
 * coordinate space.
 *
 * If the given position is outside the bounds of all outputs, the pointer
 * will be warped to the closest point inside an output instead.
 *
 * This request modifies window management state and may only be made as
 * part of a manage sequence, see the river_window_manager_v1 description.
 */
static inline void
river_seat_v1_pointer_warp(struct river_seat_v1 *river_seat_v1, int32_t x, int32_t y)
{
	wl_proxy_marshal_flags((struct wl_proxy *) river_seat_v1,
			 RIVER_SEAT_V1_POINTER_WARP, NULL, wl_proxy_get_version((struct wl_proxy *) river_seat_v1), 0, x, y);
}

/**
 * @ingroup iface_river_pointer_binding_v1
 * @struct river_pointer_binding_v1_listener
 */
struct river_pointer_binding_v1_listener {
	/**
	 * the bound pointer button has been pressed
	 *
	 * This event indicates that the pointer button triggering the
	 * binding has been pressed.
	 *
	 * This event will be followed by a manage_start event after all
	 * other new state has been sent by the server.
	 *
	 * The compositor should wait for the manage sequence to complete
	 * before processing further input events. This allows the window
	 * manager client to, for example, modify key bindings and keyboard
	 * focus without racing against future input events. The window
	 * manager should of course respond as soon as possible as the
	 * capacity of the compositor to buffer incoming input events is
	 * finite.
	 */
	void (*pressed)(void *data,
			struct river_pointer_binding_v1 *river_pointer_binding_v1);
	/**
	 * the bound pointer button has been released
	 *
	 * This event indicates that the pointer button triggering the
	 * binding has been released.
	 *
	 * Releasing the modifiers for the binding without releasing the
	 * pointer button does not trigger the release event. This event is
	 * sent when the pointer button is released, even if the modifiers
	 * have changed since the pressed event.
	 *
	 * This event will be followed by a manage_start event after all
	 * other new state has been sent by the server.
	 *
	 * The compositor should wait for the manage sequence to complete
	 * before processing further input events. This allows the window
	 * manager client to, for example, modify key bindings and keyboard
	 * focus without racing against future input events. The window
	 * manager should of course respond as soon as possible as the
	 * capacity of the compositor to buffer incoming input events is
	 * finite.
	 */
	void (*released)(void *data,
			 struct river_pointer_binding_v1 *river_pointer_binding_v1);
};

/**
 * @ingroup iface_river_pointer_binding_v1
 */
static inline int
river_pointer_binding_v1_add_listener(struct river_pointer_binding_v1 *river_pointer_binding_v1,
				      const struct river_pointer_binding_v1_listener *listener, void *data)
{
	return wl_proxy_add_listener((struct wl_proxy *) river_pointer_binding_v1,
				     (void (**)(void)) listener, data);
}

#define RIVER_POINTER_BINDING_V1_DESTROY 0
#define RIVER_POINTER_BINDING_V1_ENABLE 1
#define RIVER_POINTER_BINDING_V1_DISABLE 2

/**
 * @ingroup iface_river_pointer_binding_v1
 */
#define RIVER_POINTER_BINDING_V1_PRESSED_SINCE_VERSION 1
/**
 * @ingroup iface_river_pointer_binding_v1
 */
#define RIVER_POINTER_BINDING_V1_RELEASED_SINCE_VERSION 1

/**
 * @ingroup iface_river_pointer_binding_v1
 */
#define RIVER_POINTER_BINDING_V1_DESTROY_SINCE_VERSION 1
/**
 * @ingroup iface_river_pointer_binding_v1
 */
#define RIVER_POINTER_BINDING_V1_ENABLE_SINCE_VERSION 1
/**
 * @ingroup iface_river_pointer_binding_v1
 */
#define RIVER_POINTER_BINDING_V1_DISABLE_SINCE_VERSION 1

/** @ingroup iface_river_pointer_binding_v1 */
static inline void
river_pointer_binding_v1_set_user_data(struct river_pointer_binding_v1 *river_pointer_binding_v1, void *user_data)
{
	wl_proxy_set_user_data((struct wl_proxy *) river_pointer_binding_v1, user_data);
}

/** @ingroup iface_river_pointer_binding_v1 */
static inline void *
river_pointer_binding_v1_get_user_data(struct river_pointer_binding_v1 *river_pointer_binding_v1)
{
	return wl_proxy_get_user_data((struct wl_proxy *) river_pointer_binding_v1);
}

static inline uint32_t
river_pointer_binding_v1_get_version(struct river_pointer_binding_v1 *river_pointer_binding_v1)
{
	return wl_proxy_get_version((struct wl_proxy *) river_pointer_binding_v1);
}

/**
 * @ingroup iface_river_pointer_binding_v1
 *
 * This request indicates that the client will no longer use the pointer
 * binding object and that it may be safely destroyed.
 */
static inline void
river_pointer_binding_v1_destroy(struct river_pointer_binding_v1 *river_pointer_binding_v1)
{
	wl_proxy_marshal_flags((struct wl_proxy *) river_pointer_binding_v1,
			 RIVER_POINTER_BINDING_V1_DESTROY, NULL, wl_proxy_get_version((struct wl_proxy *) river_pointer_binding_v1), WL_MARSHAL_FLAG_DESTROY);
}

/**
 * @ingroup iface_river_pointer_binding_v1
 *
 * This request should be made after all initial configuration has been
 * completed and the window manager wishes the pointer binding to be able
 * to be triggered.
 *
 * This request modifies window management state and may only be made as
 * part of a manage sequence, see the river_window_manager_v1 description.
 */
static inline void
river_pointer_binding_v1_enable(struct river_pointer_binding_v1 *river_pointer_binding_v1)
{
	wl_proxy_marshal_flags((struct wl_proxy *) river_pointer_binding_v1,
			 RIVER_POINTER_BINDING_V1_ENABLE, NULL, wl_proxy_get_version((struct wl_proxy *) river_pointer_binding_v1), 0);
}

/**
 * @ingroup iface_river_pointer_binding_v1
 *
 * This request may be used to temporarily disable the pointer binding. It
 * may be later re-enabled with the enable request.
 *
 * This request modifies window management state and may only be made as
 * part of a manage sequence, see the river_window_manager_v1 description.
 */
static inline void
river_pointer_binding_v1_disable(struct river_pointer_binding_v1 *river_pointer_binding_v1)
{
	wl_proxy_marshal_flags((struct wl_proxy *) river_pointer_binding_v1,
			 RIVER_POINTER_BINDING_V1_DISABLE, NULL, wl_proxy_get_version((struct wl_proxy *) river_pointer_binding_v1), 0);
}

#ifdef  __cplusplus
}
#endif

#endif
